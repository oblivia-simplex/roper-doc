<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title></title>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="./reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="./reveal.js/css/theme/moon.css" id="theme"/>


<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = './reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><p class="date">Created: 2018-04-14 Sat 16:06</p>
</section>
<div>
\begin{savequote}
\textsc{Invisigoth}: Donald wrote an interlocked sequence of viruses 15 years ago. It got loose on the net.

\textsc{Mulder}: Wait, what do you mean, ‘got loose?'

\textsc{Invisigoth}: He let it loose … so it could evolve in its natural environment. Urschleim in silicon.

\textsc{Scully}: ‘Urschleim in silicon?'

\textsc{Invisigoth}: The primordial slime? The ooze out of which all life evolved. Except this time it’s artificial slime – artificial life...
\qauthor{William Gibson, "Kill Switch" (\emph{X-Files}, season 5, episode 11)}
\end{savequote}

</div>

<section>
<section id="slide-orgab007ce">
<h2 id="orgab007ce"><span class="section-number-2">1</span> Introduction</h2>
<p>
<a id="org7e85eec"></a>
</p>
</section>
<section id="slide-orgb7faccf">
<h3 id="orgb7faccf"><span class="section-number-3">1.1</span> What is the aim of this research?</h3>
<p>
<a id="org111df68"></a>
</p>

<p>
This thesis explores the use of evolutionary techniques in rop. It details
the design and implementation of an engine called roper, which employs the
methods of gp to generate declaratively specified rop payloads
from scratch, and walks through a series of experiments that establish the
feasibility of this approach. Since this is, to the best of my knowledge, the
first time that evolutionary techniques have been put to work in the field of
return-oriented programming, my intention is only to establish a <i>proof of
concept</i>, rather than to advance the state of the art in terms of performance
and precision.<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

</section>
<section id="slide-orge7e41c0">
<h3 id="orge7e41c0"><span class="section-number-3">1.2</span> Why is this interesting?</h3>
<p>
The &ldquo;crafted input&rdquo; by means of which a hacker controls the execution of
an exploited system is typically best understood as a sequence of instructions
for a previously unknown virtual machine, whose supervenience on the intended
machine is accidental, and often unknown before it is exploited.
These payloads tend to be short, highly constrained by contingent
pressures, and forged from obscure and irregular materials. These factors,
which tend to greatly increase the ratio of difficulty to functionality in
payload implementation, for human programmers, also make the problem
well suited to evolutionary approaches. This, at least, was the intuition
that sparked this project. The hope is that by putting evolutionary techniques
to work in this field, we can better explore and understand the algorithmic
wilderness that supervenes on our machines, and gain a deeper sense of the
possibilities harboured there.
</p>

</section>
<section id="slide-org976fd0f">
<h3 id="org976fd0f"><span class="section-number-3">1.3</span> Where can this work be applied?</h3>
<p>
The techniques developed here can quite viably be put to work in the field of
offensive cybersecurity, and be used to generate swarms of attack payloads whose
diversity is, for all intents and purposes, unbounded. The technology developed
here could, with minor adaptations,<sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> used
to test and train ids, or provide one more instrument in the penetration
tester&rsquo;s toolbox.
</p>

</section>
<section id="slide-orgb28f1f0">
<h3 id="orgb28f1f0"><span class="section-number-3">1.4</span> Who is this for?</h3>
<p>
I hope that the work presented here may be of interest to newcomers to
both low-level exploit development and genetic programming, and to those
who may have a solid background in one but not the other. The work presented
here shows how problems drawn from the field of application security provide
an extremely fertile ground for evolutionary experimentation, which I believe
is of interest in its own right, independent of applications. 
</p>

<p>
Of course, there&rsquo;s nothing preventing the use of this technology by malicious
actors, and in this respect roper is in the same boat as any other product
of security research &#x2013; the only defence against use by blackhats, after all,
would be to ensure that the research is useless. This isn&rsquo;t just an unavoidable
aspect of security research, it&rsquo;s one of its essential motors. Without the endless
arms race between attacker and defender, between whitehat and blackhat, it&rsquo;s
unlikely we&rsquo;d have even an <i>sliver</i> of the understanding of our own
abstractions &#x2013; and of all their leaky concretizations &#x2013; that the concern for
security demands. The harsh reality that any worthwhile development in security
can be picked up and studied by blackhats seeking to use, abuse, apply, subvert,
and exploit it, isn&rsquo;t something we should shy away from or apologise for. It&rsquo;s the
crucible in which our ideas and their implementations are tested, and a tireless
generator of new ideas in its own right. The economic and political fates of
attackers and defenders may rise and fall in the arena of applied cybersecurity,
but the science ratchets on, day and night.
</p>
<p>
That said, we should nevertheless take a moment to consider the risks posed
by the introduction of evolutionary malware, or any technology that could facilitate
its development, into the existing information security ecosystem.
</p>


<p>
I have decided to make the source code for this project available to the public,
warts and all, and place it under the gpl. It can be accessed on Github,
at <a href="https://github.com/oblivia-simplex/roper">https://github.com/oblivia-simplex/roper</a>, and freely experimented with. 
</p>


</section>
<section id="slide-org9aa2ab6">
<h3 id="org9aa2ab6"><span class="section-number-3">1.5</span> Synopsis</h3>
<p>
<a id="org5d4afdf"></a>
</p>

<p>
In Chapter <a href="#/slide-orgead214a">2</a>, I set up some of the conceptual
background for this study, exploring the broader problems broached by rop, 
and why it presents itself as an intriguing problem domain for evolutionary
computation, before surveying a handful of historical efforts to
enlist evolutionary techniques in offensive security and malware
design, in Chapter <a href="#/slide-org10a872a">3</a>.
</p>

<p>
Chapter <a href="#/slide-org765e5dc">4</a> introduces my contribution to research in the field of
evolutionary offensive security, with an overview of the design and implementation of
a rop evolution engine called roper.
</p>

<p>
Chapter <a href="#/slide-org64aa169">5</a> goes over a handful of experimental studies with
roper, and consequent modifications to the design. 
</p>

<p>
Chapter <a href="#/slide-org0393a4c">6</a> lays out some directions for future work and study on this
topic, and brings this thesis to a conclusion.
</p>



<div>
\begin{savequote}
Between the idea\\  
And the reality\\  
Between the motion\\ 
And the act\\
Falls the Shadow
\qauthor{T.S. Eliot, "The Hollow Men"}
\end{savequote}

</div>
</section>
</section>
<section>
<section id="slide-org0c8a61a">
<h2 id="org0c8a61a"><span class="section-number-2">2</span> Weird Machines and Return-Oriented Programming</h2>
<p>
<a id="orgead214a"></a>
<a id="orge38037c"></a>
</p>
</section>
<section id="slide-orgad9cc81">
<h3 id="orgad9cc81"><span class="section-number-3">2.1</span> A Fundamental Problem of Cybersecurity</h3>
<p>
<a id="org752daa7"></a>
</p>

<p>
At the most elementary strata of computation &#x2013; whether we are dealing with the austere
formalism of the lambda calculus, the ideal Von Neumann machine model, or the
various instruction set architectures that concretize it &#x2013; the distinction between
data and code, on which so much of practical computing is founded, tends to
fade from view.<sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>
</p>

<p>
But at any level where one computational system interfaces with another, &ldquo;in the
real world&rdquo;, the problem of imposing and maintaining this distinction is
critical &#x2013; even, I would argue, the <i>fundamental</i> problem of cybersecurity.
What we call data, generally speaking, is information that one system (A)
receives from another (B), or the result of applying any sequence of
transformations to that information. &ldquo;Data&rdquo;, in other words, is just what
flows from one system to another. Insofar as those systems are meant to be
<i>distinct</i> &#x2013; with different capabilities, different access rights, and so on &#x2013;
the notion of data is immediately bound up with those of security and trust. 
If we are to have any assurances at
all about the behaviour of system A, after all, A must, by design, place some constraints
on how it lets itself be steered by the data it receives &#x2013; unless, of course,
it is <i>intended</i> to be a general programming environment.<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup> Data is
<i>just</i> data, as opposed to &ldquo;code&rdquo;, only to the extent that such constraints hold.
</p>

<p>
Nothing makes this clearer than rce attacks, each of
which can be seen as a &ldquo;proof by construction&rdquo; that what we assumed to be
&ldquo;merely data&rdquo; was in fact code for a machine that we didn&rsquo;t understand.<sup><a id="fnr.5" class="footref" href="#fn.5">5</a></sup> In many such cases, the breach occurs
when the attacker slips past the <i>intended</i> interface and dispatches
instructions (performs state transitions) on one or more of the system&rsquo;s
&ldquo;internal&rdquo; components. Take the classic sql injection attack, for example. The
attack succeeds when the attacker crafts the input data to the system in such a
way that the system interprets some portion of that data as code. In the simplest
cases, this may be done by inserting a single quotation mark in the text
provided to an input field. If this input is not safely parsed by the frontend,
then any text <i>following</i> the delimiting quote will be interpreted as additional
sql instructions, and executed by the backend. The injected delimiter plays the
role of an unsuspected pivot between data and code, switching the context of the
input string to an sql execution environment.
</p>
<p>
Something similar happens in the classic style of buffer overflow attack
described in Aleph One&rsquo;s famous textfile, &ldquo;Smashing the Stack for Fun and
Profit&rdquo; <a href="~/org/bibliography.bib::aleph96">~/org/bibliography.bib::aleph96</a>. The <i>pivot</i>, in that case, is achieved by the attacker supplying an
input string that the vulnerable application writes to a buffer that has not
been allocated enough space to contain it. In many cases, this gives the
attacker the ability to write to stack memory &ldquo;beneath&rdquo; the ill-measured buffer.
What makes this dangerous is that, according to a certain, widely implemented
abstract machine model, which for lack of a better name,<sup><a id="fnr.6" class="footref" href="#fn.6">6</a></sup> we could call the &ldquo;spmm&rdquo;, the return address of each subroutine is often stored on
the stack as well, just a few words below the space where local variables are
stored. This lets the attacker control the return address, which can be
redirected to <i>another</i> region of the input data, where the attacker has encoded
a sequence of machine code instructions for the vulnerable system&rsquo;s cpu.
</p>
<p>
In these cases, and in many, many more, the attacker succeeds in exploiting some
oversight in the design or implementation of the input handler, in such a way
that the vulnerable system treats some portion of the input just as it would
treat its own code. In each of these cases, it&rsquo;s possible to distinguish two
distinct moments:
</p>

<ol>
<li>the delivery mechanism, or &ldquo;pivot&rdquo;, of the attack, where the input
&ldquo;data&rdquo; is transubstantiated into &ldquo;code&rdquo; of some sort &#x2013; the aberrant delimiter in the sql
injection, and the corruption of the instruction pointer, in the case of the
buffer overflow, are both instances of this;</li>

<li>the &ldquo;payload&rdquo;, through which the hacker exercises fine-grained control
over the vulnerable system. In the case of the buffer overflow attack, this
might be a string of shellcode. In the case of the sql injection, a sequence of
one or more sql expressions or operations.</li>

</ol>

<p>
This is the general outlook that seems to motivate most defensive tactics in
computer security. Take, for instance, a tactic that has been widely deployed in
an effort to defend against shellcode attacks. These attacks play on the fact
that, to the cpu, &ldquo;code&rdquo; is wherever the ip is pointing. The
stack overflow vulnerability detailed by Aleph One is one such delivery
mechanism, but the general strategy of feeding the vulnerable system machine
code instructions in the form of input data, and then redirecting the program
counter so that it points to that data, and executes it as code, has other forms
as well &#x2013; such as use-after-free attacks, which may exploit a lack of
coordination in heap memory management to overwrite a virtual function pointer
(an object method, for example) with a pointer to the attacker&rsquo;s shellcode.
Defensive measures against these attacks typically follow one of two
prongs: either they inhibit the <i>pivot</i> stage, or they 
inhibit the <i>payload</i>.
</p>

<p>
With respect to the pivot stage, buffer overflow attacks can be prevented,
piecemeal, by carefully constraining the data that&rsquo;s written to fixed-length
buffers on the stack (use <code>strncpy()</code> instead of <code>strcpy()</code>, etc.). The onus,
in this case, falls on the developer, or her linter. They can
also be mitigated by the compiler, by inserting a random string as a sort of
tripwire between the writeable stack buffer and the return address, such that
any attempt to overwrite that portion of the stack would also corrupt this
randomized value or &ldquo;stack canary&rdquo;. Neither of these mitigations prevent a block
of malicious code that the attacker has written to memory from being executed,
should some other means of corrupting the instruction pointer become available.
</p>

<p>
The sort of attack that Aleph One describes could also be blocked by
obstructing the attacker&rsquo;s ability to pass control to the payload, rather than
their ability to achieve the initial corruption of the instruction pointer. This
is what is achieved, for example, through what Windows natives call &ldquo;dep&rdquo;,
and what Unix dwellers call, a bit less
pronounceably, &ldquo;w+x&rdquo;, whereby the memory pages of a
running process may be mapped as writeable, or may be mapped as executable, but
may no longer be mapped as <i>both</i>.<sup><a id="fnr.7" class="footref" href="#fn.7">7</a></sup> With this mitigation
in place, the attacker may succeed in corrupting the instruction pointer, and
may succeed in loading their attack code into memory, but is unable to pass
control to the latter &#x2013; an instruction pointer dereferenced to a non-executable
location in memory will result in a segmentation fault (as Unixers call it) or
an access violation error (as it&rsquo;s known in Windows). This may succeed in
crashing the program, and thereby carrying out a non-trivial denial-of-service
(DoS) attack, but at no point does the attacker achieve fine-grained control of
the process.
</p>

<p>
There is another way of looking at all of this, which is both more general and
more fruitful. As hacker folklore is fond of repeating, what we call a system&rsquo;s
&ldquo;code&rdquo; is, in some sense, nothing but <i>the specification of a state machine
driven by the input data</i>.<sup><a id="fnr.8" class="footref" href="#fn.8">8</a></sup> As Halvar Flake explains, to write a program
is to constrain the virtually boundless potential of a general computer so as to
have it emulate &ldquo;a specific finite-state machine that addresses your problem&rdquo;.
&ldquo;The machine that address the problem,&rdquo; he go on,
</p>

<blockquote nil>
<p>
is the <i>intended finite state machine</i> [&#x2026;]
</p>

<p>
The security properties of the ifsm are &rsquo;what we want to be true&rsquo; for the
ifsm. This is needed to define &rsquo;winning&rsquo; for an attacker: He wins when he
defeats the security properties of the ifsm. 
</p>
</blockquote>



<p>
Assuming that there has been no trivial misconfiguration of the ifsm, and that
it is, on its own particular level of abstraction, consistent, the
attacker defeats those security properties by ferreting out a leak in that abstraction, and tapping into a reserve of computational power
that the programmer had considered foreclosed by the ifsm. This is done by
<i>first</i> finding a way to access a state from the ifsm that is not accounted
for by the ifsm's design. These are what Sergey Bratus <a href="~/org/bibliography.bib::bratus_homepage">~/org/bibliography.bib::bratus_homepage</a> calls &ldquo;weird
states&rdquo;. (An example is the state that the cpu enters when its instruction
pointer has been overwritten by input.) This is what we have called the
<i>pivot</i> of the attack.
</p>

<p>
&ldquo;Once a weird state is entered&rdquo;, Flake continues,
</p>
<blockquote nil>
<p>
many other weird states can be reached by
applying the transitions intended for sane states on them. A new computational
device emerges, the &ldquo;weird machine&rdquo;. The <i>weird machine</i> is the computing device
that arises from the operation of the emulated transition of the ifsm on weird
states. 
</p>

<p>
&#x2026;Given a method to enter a weird state from a set of particular sane states,
<i>exploitation</i> is the process of:
</p>
<ol>
<li>setup (choosing the right sane state)</li>
<li>instantiation (entering the weird state), and</li>
<li>programming of the weird machine</li>

</ol>
<p>
so that security properties of the ifsm are violated. 
</p>
</blockquote>


<p>
The concept of a <i>weird machine</i> opens onto an extremely versatile and general
theory of exploitation, which will remain the backdrop for much of what follows.
</p>

</section>
<section id="slide-orge384fa0">
<h3 id="orge384fa0"><span class="section-number-3">2.2</span> Return and Jump Oriented Programming</h3>
<p>
<a id="orgf915520"></a>
</p>

<p>
It is due to a leaky abstraction of this nature, and an unswerving view of
the underlying cpu <i>from the perspective of application programmers and
compilers</i>, blinkered by what Meredith Patterson has called &ldquo;boundaries of
competence&rdquo; <a href="~/org/bibliography.bib::patterson_2012">~/org/bibliography.bib::patterson_2012</a>, that w+x ultimately fails to prevent remote code execution.
It fails because it is built on an insufficiently general concept of <i>code</i>.
</p>

</section>
<section id="slide-orgf1a86d7">
<h4 id="orgf1a86d7"><span class="section-number-4">2.2.1</span> The Structured Programming Machine Model</h4>
<p>
<a id="org901d0b5"></a>
</p>



<p>
According to this model, computation proceeds by iterating through a buffer of
instructions in a designated segment of memory, using a designated register, the
&ldquo;program counter&rdquo; or &ldquo;instruction pointer&rdquo;, to track the location of the next
instruction to execute (we&rsquo;ll call this the IP when referring to its abstract
role, but its concretization has different names on different architectures &#x2013;
EIP on x86, RIP on x86_64, pc on arm, etc.) Each instruction prompts the
processor to mutate its state (its registers, memory, etc.) in some fashion.
&ldquo;Code&rdquo; is wherever ip points, and he instruction set is fixed by the
architecture.
</p>

<p>
On this basis is implemented the <i>procedural</i> layer of abstraction, which the
underlying architecture is largely designed to accommodate. According to this
layer, a program is typically broken up into a collection of <i>subroutines</i> (or
&ldquo;functions&rdquo;). A subroutine is characterized by two essential properties:
</p>
<ol>
<li>it has a local variable scope, and</li>
<li>it can be run, or &ldquo;called&rdquo;, as a cohesive unit, with execution
<i>returning</i> to the place it is run from once it completes Abstractly, both</li>

</ol>
<p>
of these properties rely on the <i>stack</i> data structure. Both the scopes, and the
execution flow, of subroutines, is organized in a first-in-last-out fashion.
</p>

<p>
Interestingly, though they are <i>conceptually</i> distinct, the data stack and the
execution stack are typically <i>interleafed</i> in practice.
</p>

<p>
This interleafing is orchestrated, on most modern architectures, by means of
three abstract registers: sp, fp, and ip. On x64_64,
these are implemented by <code>RSP</code>, <code>RBP</code>, and <code>RIP</code>, respectively. On arm, by
<code>SP/R13</code>, <code>FP/R12</code>, and <code>SP/R15</code>. When a subroutine is called, the address of
the next instruction address in the calling routine is typically pushed onto the
stack. (In some cases a special register is used to hold the most recent return
address &#x2013; the top of the abstract calling stack &#x2013; as an optimization. This is
the role of lr on arm. For nested subroutine
calls, however, it&rsquo;s necessary to fall back to a stack structure. The fp is then
used to mark the base of the scope of stack memory that belongs to the
subroutine. Any memory beyond fp is the subroutine&rsquo;s own to make use of,
though this claim is abandoned when the subroutine returns. Returning from a
subroutine, in most cases, is just a matter of popping the return address from
the control stack, and loading it into the instruction pointer. On x64_64, this
is accomplished by the <code>ret</code> instruction, on arm, by <code>pop {pc}</code>, and on MIPS
by first loading a register from the top of the stack, and then jumping to that
register.
</p>

<p>
This is, of course, why an attacker can &ldquo;smash the stack for fun and profit&rdquo;.
Even if they must tailor their attack for a specific architecture, they are
attacking a vulnerability in the C virtual machine: that improperly handled
writes to the data stack can corrupt the control stack with which it is
interleafed. The interleafing makes accessible to the attacker the critical kind
of <i>weird states</i> on which their attack pivots. In executing this attack, the
attacker violates the conceptual separation of schematically interleafed control
and data stacks, but otherwise remains within the same basic abstract machine
model. An elegant shellcode payload will even take care to restore any corrupted
registers, clear its own local stack, and return control to the caller, as if
nothing out of the ordinary had happened. The attacker is descending to a lower
level of abstraction, but not an entirely foreign one. It is a level already
implicit, and (leaks notwithstanding) encapsulated in the victim process.
</p>

</section>
<section id="slide-org0a016f2">
<h4 id="org0a016f2"><span class="section-number-4">2.2.2</span> The ROP Virtual Machine</h4>
<p>
<a id="orgfe77228"></a>
</p>

<p>
A rop chain can be seen as a program written to run on a weird machine, which just
happens to supervene on the same process mobilized by the programmer&rsquo;s machine
model, the process that is <i>supposed</i> to be executing a perfectly normal
program. Let&rsquo;s call this a rovm.
</p>

<p>
Like the programmer&rsquo;s machine model, the rovm works by iterating through a
sequence of instructions, tracking the location of the next instruction by means
of a special registerr, and in the process mutates the cpu context. But the
instruction set used for this machine is <i>not</i> the instruction set targetted by
its host. It is an emergent instruction set, peculiar to the state of
conventionally executable memory at the time of the pivot. These instructions
are called &ldquo;gadgets&rdquo;, and are composed of chunks of data that is:
</p>
<ol>
<li>already mapped to executable memory &#x2013; on Unix systems, this
generally means the <code>.text</code> section of the binary;</li>
<li>performs some mutation of cpu context when conventionally
executed, and</li>
<li>returns control of execution flow to the attacker-supplied data
after executing. Trait #3 is typically satisfied by chosing gadgets that</li>

</ol>
<p>
end with a <b>return</b> instruction, or some semantic equivalent &#x2013; any combination
of instructions that results in a value from the stack being loaded into the
instruction pointer. This can also be accomplished by means of a combination of
<b>load</b> and <b>jump</b> instructions, which gives us &ldquo;jop&rdquo;, or
jump-oriented-programming, but the difference between jop and rop is not
critical here, and for our purposes &ldquo;rop&rdquo; will be used to refer to both
varieties. In general terms, 
</p>

<blockquote nil>
<p>
To be able to build a program from gadgets, they must be combinable. Gadgets
are combinable if they end in an instruction that, controlled by the user, 
alters the control flow. Instructions which end gadgets are named &rsquo;free branch&rsquo;
instructions. A &rsquo;free branch&rsquo; instruction must satisfy the following properties:
</p>

<ul>
<li>The control flow must change at this instruction.</li>

<li>The target of the control flow must be controllable (free) such that the
input from a register or stack defines the target. <a href="~/org/bibliography.bib::kornau09">~/org/bibliography.bib::kornau09</a></li>

</ul>
</blockquote>

<p>
The rovm is, in some sense, an essentially parasitic, or supervenient,
creature. Its instruction set is cobbled together from chunks of machine code
whose frequency in the victim process is largely a result of the process&rsquo;s
intended code being crafted with the procedural abstraction in mind.
</p>

<p>
This point is worth dwelling on for a moment, because it beautifully illustrates
the ingenuity of rop. w+x, after all, <i>prevents</i> the data stack, which
needs to remain writeable by the process, from being used as a code buffer, the
way it is in a shellcode attack. But the schematic idea of <i>code</i> that w+x 
guards against is code as understood by the programmer&rsquo;s machine model. The
rovm <i>is</i> able to use the data stack as a code buffer because it represents a
change in perspective regarding what counts as code, what counts as an
instruction, and what counts as an instruction pointer. Even when a strict
separation of &ldquo;data&rdquo; and &ldquo;code&rdquo; is in place (via w+x, and/or the
hardware restrictions imposed by a Harvard Bus architecture), the spmm <i>expects</i>
an interleafing of the control and data stacks, and so cannot very well ban the
presence of code segment pointers from its stack, or prevent the loading of the
pointer at the top of its stack into its own designated instruction pointer. But
these two factors are all that are needed in order to superimpose the rovm on
top of the spmm: we don&rsquo;t need to execute spmm level instructions from the stack,
we just need to be able to use <i>data</i> on the stack to <i>influence</i> the execution
of instructions, in a fine-grained fashion. But this is just what the <code>return</code>
instruction does, in the spmm: it fetches data from the top of the stack, maps
that data to an address in its own code buffer, and then executes the
instructions it finds there, until it is instructed to fetch the next pointer
from its stack. In this way, the spmm already <i>implies</i> the possibility of the
rovm, which is its shadow. The \gls{spmm}&rsquo;s interleafing of control stack and data
stack makes the principled separation of the writeable and the executable all
but futile, since the latter represents a true separation of <b>code</b> and <b>data</b>
only if the abstract machine model stays fixed.
</p>

<p>
To paraphrase Eliot: Between the programmer&rsquo;s abstract machine model, and the actual behaviour of the
cpu, between the specification and the implementation, falls the shadow.
</p>

</section>
<section id="slide-orgb5d04c9">
<h3 id="orgb5d04c9"><span class="section-number-3">2.3</span> Prior Art: Exploit Engines and Weird Compilers</h3>
<p>
A handful of technologies have already been developed for the automatic
generation of ROP-chains. These range from tools that use one of several
determinate recipes for assembling a chain &#x2013; such as the Corelan Team&rsquo;s very
handy <code>mona.py</code> <sup><a id="fnr.9" class="footref" href="#fn.9">9</a></sup> &#x2013; to tools
</p>
<p>
We are aware of two such projects at the moment: <i>Q</i> <a href="~/org/bibliography.bib::schwartz11">~/org/bibliography.bib::schwartz11</a>, 
which is able to compile instructions in a simple scripting
language into ROP chains, and which has been shown to perform well, even with
relative small gadget sets, and ROPC, which grew out of its authors&rsquo; attempts to
reverse engineer <i>Q</i>, and extend its capabilities to the point where it could
compile ROP-chains for scripts written in a Turing-complete programming
language. <sup><a id="fnr.10" class="footref" href="#fn.10">10</a></sup> The latter has since spawned a fork that aims to use
ROPC&rsquo;s own intermediate language as an LLVM backend, which, if successful, would
let programs written in any language that compiles to LLVM&rsquo;s intermediate
language, compile to ROPC-generated ROP-chains as well.
</p>



<p>
Another, particularly interesting contribution to the field of automated
ROP-chain generation is <i>Braille</i>, which automates an attack that its developers
term &ldquo;Blind Return-Oriented Programming&rdquo;, or BROP <a href="~/org/bibliography.bib::bittau14">~/org/bibliography.bib::bittau14</a>. BROP solves the
problem of developing ROP-chain attacks against processes where not only the
source code but the binary itself in unknown. <i>Braille</i> first uses a
stack-reading technique to probe a vulnerable process (one that is subject to a
buffer overflow and which automatically restarts after crashing), to find enough
gadgets, through trial and error, for a simple ROP chain whose purpose will be
to write the process&rsquo;s executable memory segment to a socket, sending that
segment&rsquo;s data back to the attacker &#x2013; data that is then used, in conjunction
with address information obtained through stack-reading, to construct a more
elaborate ROP-chain the old-fashioned way. It is an extremely interesting and
clever technique, which could, perhaps, be fruitfully combined with the genetic
techniques I will outline here.
</p>

</section>
<section id="slide-org6d177ad">
<h3 id="org6d177ad"><span class="section-number-3">2.4</span> Prospects for Genetic ROP-chain Crafting</h3>
<p>
To the best of our knowledge, no attempt has yet been made to bring evolutionary
methods to bear on the problem of ROP-chain generation; there is little
precedence, in fact, for any use of genetic techniques to craft exploits.
</p>







<div>
\begin{savequote}
The biological analogy was obvious; evolution would favor such code,
especially if it was designed to use clever methods of hiding itself and using
others' energy (computing time) to further its own genetic ends. So I wrote some
simple code and sent it along in my next transmission. Just a few lines in
Fortran told the computer to attach these lines to programs being transmitted to
a certain terminal. Soon enough -- just a few hours -- the code popped up in
other programs, and started propagating.
\qauthor{Gregory Benford, Afterword to "The Scarred Man"}
\end{savequote}

</div>
</section>
</section>
<section>
<section id="slide-org5543573">
<h2 id="org5543573"><span class="section-number-2">3</span> Natural Selection Considered Harmful: A Brief History of Evolutionary Computation in Offensive Security</h2>
<p>
<a id="orgf7e423c"></a>
<a id="org10a872a"></a>
</p>

<p>
While evolutionary techniques have been more or less frequently employed in the
field of <i>defensive</i> security &#x2013; where they are put to work much in the same way
as other machine learning algorithms, and built into next-generation firewalls,
intrusion-detection systems, and so on &#x2013; there has been far less exploration of
these techniques in the realm of offensive security. This is not to say,
however, that the idea has never occurred to anyone &#x2013; the idea seems to have
captured the imagination of hackers, malware engineers, and cyberpunk science
fiction authors, ever since there have been such things.
</p>

</section>
<section id="slide-org6a2c878">
<h3 id="org6a2c878"><span class="section-number-3">3.1</span> Viruses and Evolutionary Computation</h3>
<p>
<a id="orgc451a80"></a>
</p>
</section>
<section id="slide-org6951fe8">
<h4 id="org6951fe8"><span class="section-number-4">3.1.1</span> 1969: Benford</h4>
<p>
The oldest occurrence of the concept of evolving, intrusive code that I was able
to excavate dates to sometime around 1969, in an experiment performed &#x2013; and
subsequently extrapolated into fiction &#x2013; by the astrophysicist and
science-fiction author, Gregory Benford, during his time as a postdoctoral
fellow at the Lawrence Radiation Laboratory, in Livermore, California. &ldquo;There
was a pernicious problem when programs got sent around for use: &lsquo;bad code&rsquo; that
arose when researchers included (maybe accidentally) pieces of programming that
threw things awry,&rdquo; Benford recalls of his time at the LRL.
</p>

<blockquote nil>
<p>
 One day [in 1969] I was struck by the thought that one might do so
intentionally, making a program that deliberately made copies of itself
elsewhere. The biological analogy was obvious; evolution would favor such code,
especially if it was designed to use clever methods of hiding itself and using
others&rsquo; energy (computing time) to further its own genetic ends. So I wrote some
simple code and sent it along in my next transmission. Just a few lines in
Fortran told the computer to attach these lines to programs being transmitted to
a certain terminal. Soon enough &#x2013; just a few hours &#x2013; the code popped up in
other programs, and started propagating. 
</p>
</blockquote>

<p>
 Benford&rsquo;s experiments
unfolded in relative obscurity, apart from inspiring a short story that he would
publish in the following year, entitled &ldquo;The Scarred Man&rdquo;. As far as we can
tell, however, the invocation of &ldquo;evolution&rdquo; remained entirely analogical, and
did not signal any rigorous effort to implement Darwinian natural selection in
the context of self-reproducing code. It was nevertheless an alluring idea, and
one that would reappear with frequency in the young craft of virus programming.
</p>

</section>
<section id="slide-orgc612f1c">
<h4 id="orgc612f1c"><span class="section-number-4">3.1.2</span> 1985: Cohen</h4>
<p>
Though anticipated by over a decade of scattered experiments, the <b>concept</b> of
&ldquo;computer virus&rdquo; made its canonical entrance into computer science in the 1985
dissertation of Fred Cohen, at the University of Southern California, <i>Computer
Viruses</i> <a href="~/org/bibliography.bib::cohen85">~/org/bibliography.bib::cohen85</a>. <i>Computer Viruses</i> is a remarkable document. Not only does it provide
the first rigorously formulated &#x2013; and <i>formalized</i> &#x2013; concept of computer
virus, which Cohen appears to have discovered independently of his predecessors
(whose work was confined to obscurity and fiction), explore that concept at the
highest possible level of generality, in the context of the Turing Machine
formalism, develop an elegant order-theoretic framework for plotting contagion
and network integrity, leverage language-theoretic insights to subvert
then-hypothetical  anti-virus software through
G&ouml;delian diagonalization, and suggest a number of defenses, such as the
cryptographic signing of executables, which are still used today, it also hints
&#x2013; elliptically &#x2013; at the potential for viral evolution. At first glance, what
Cohen calls the <i>evolution</i> of a virus resembles what would later be called
<i>polymorphism</i> or even <i>metamorphism</i>
&#x2013; the process of altering the <i>syntactic</i> structure of the pathogen in the
course of infection, so that the offspring is not simply a copy of the parent.
This is indeed enough to expose the virus to a certain amount of differential
selective pressure, so long as antiviral software (the virus&rsquo;s natural predator)
pattern matches on the virus&rsquo;s syntactic structure (the precise sequence of
opcodes used), or on some low-level features on which the syntax supervenes (one
or more bitwise hashes of the virus, for example). But Cohen goes a step further
than this, and considers a far broader range of infection transformations that
do <i>not</i> preserve semantic invariants. That is to say, he considers reproduction
operators &#x2013; operators embedded in the virus itself, which, following
Spector <a href="~/org/bibliography.bib::spector01">~/org/bibliography.bib::spector01</a>, we can call &ldquo;autoconstructive operators&rdquo; &#x2013; which
generate semantically dissimilar offspring.
</p>

<p>
Cohen thus deploys all the essential instruments for an evolutionary treatment
of viruses:
</p>

<ol>
<li>reproduction with variation (the &ldquo;genetic operators&rdquo;)</li>
<li>selection (detection by recognizers, or &ldquo;antivirus&rdquo; software)</li>
<li>differential survival (there is no recognizer that can recognize
every potential virus, as a corollary of Rice&rsquo;s theorem <a href="~/org/bibliography.bib::rice53">~/org/bibliography.bib::rice53</a>)</li>

</ol>

<p>
He goes no further in systematizing this dimension of the problem,
unfortunately, and nowhere in this text do we find anything that either draws on
or converges with contemporaneous research into evolutionary computation as a
mechanism for program discovery or artificial intelligence.
</p>

<p>
Cohen can hardly be blamed for this, of course. The dissertation as it stands is
a work of rare ambition and scope. The casual observer of virus research and
development over the past three decades, however, might be surprised by the
impression that so little has been done to bridge the distance that lay between
it and study of evolutionary computation. While the rhetoric surrounding the
study of computer viruses remained replete with references to evolution, to
ecology, to natural selection, and so on,  efforts to actually
integrate the two fields appear to have been rare.
</p>

<p>
This impression is not wholly accurate, however. Closer study shows us that the
experimental fringe of the vx scene has indeed retained an interest in exploring
the use of genetic methods in their work. If this has gone relatively unnoticed
by the security community, this is likely for one or two reasons:
</p>

<ol>
<li>the vxer who have implemented genuinely evolutionary methods in their
work seem to be motivated primarily by hacker&rsquo;s curiosity and not by monetary
gain. The viruses they write are intended to be more
playful than harmful, and it appears that several of the evolutionary viruses
I have found were sent directly by their authors to antivirus researchers, or
published, along with source code and documentation, on publicly accessible
websites and vxer ezines.</li>

<li>Of course, we should consider the non-negligible selection
effect implied in reason #1: it&rsquo;s not surprising that the viruses <i>that I was
able to find</i> in the course of writing this chapter are those circulated by
the grey-hat vxer community, as opposed to those developed, or contracted, by
intelligence agencies and criminal syndicates, who tend to hold somewhat more
stringent views on matters of intellectual property. And so a second,
plausible-enough explanation presents itself: it is possible that far less
playful evolutionary viruses <i>do</i> exist in the wild, but that they tend to
either go undetected, are used primarily for targetted operations less
exposed to the public, or that they are not being properly recognized or
reported in the security bulletins released by the major antivirus companies.</li>

</ol>

</section>
<section id="slide-org7550faf">
<h4 id="org7550faf"><span class="section-number-4">3.1.3</span> Nonheritable Mutations in Virus Ontogeny</h4>
<p>
For reasons of stealth, virus writers have explored ways of incorporating
variation into their mechanisms of infection and replication. The first trick to
surface was simple encryption, employed for the sake of obfuscation rather than
confidentiality. This first became widely known with the Cascade virus, circa
1988 <a href="~/org/bibliography.bib::szor05">~/org/bibliography.bib::szor05</a>. Viruses using this obfuscation method would encrypt their contents using
variable keys, so that the bytewise contents of their bodies would vary from
transmission to transmission. The encryption engine itself, however, would
remain unencrypted and exposed, and so antiviral software simply looked for
recognizable encryptors instead.
</p>

<p>
Next came oligomorphic viruses, starting with Whale in 1990 <a href="~/org/bibliography.bib::whale90">~/org/bibliography.bib::whale90</a>.
These would use one of a fixed set of encryption engines, adding some
variability to the mix. This would make the problem of detection some 60 or 90
times harder, depending on the number of engines, but such distances are easily
closed algorithmically.
</p>

<p>
Next came polymorphic engines, which would scramble and rebuild their own
encryption engine with each transmission, while preserving all the necessary
semantic invariants. The antivirus developers countered by running suspicious
code in emulators, waiting until the body of the virus was decrypted before
attempting to classify it.
</p>

<p>
The last and most interesting development in this (pre-genetic) sequence rests
with <i>metamorphic</i> viruses, which redirected the combinatorial treatment that
polymorphics reserved for the encryption engine onto the virus body as a whole.
There was no longer any need for encryption, strictly speaking, since the
purpose of encryption in polymorphism is to obfuscate, not to lock down, and
this allowed viruses to avoid any reliance on the already somewhat suspicious
business of decrypting their own code before running.
</p>

<p>
In biological terms, what we&rsquo;re seeing with both polymorphic and metamorphic
viruses is a capacity for ontogenetic variation. While it is possible for the
results of metamorphic transformations to accumulate over generations, in most
cases (unless there are bugs in the metamorphic engine), these changes are
semantically neutral, and do not affect the functionality of the code (though
this raises a subtle point regarding what we are to count as &rsquo;functionality&rsquo;,
especially when faced with detectors that turn syntactic quirks and timing
sidechannels into a life-or-death matter for the virus). They are also, in
general, reversible, forming a group structure. So long as they are not
subjected to selective pressure, and complex path-dependencies don&rsquo;t form, the
&rsquo;evolution&rsquo; of a metamorphic virus typically has the form of a random walk.
</p>

<p>
It is nevertheless evident how close we are to an actual evolutionary process.
</p>

</section>
<section id="slide-orgacd578c">
<h4 id="orgacd578c"><span class="section-number-4">3.1.4</span> 2002: MetaPHOR (W32/Simile, {W32,Linux}/Simile.D, Etap.D)</h4>
<p>
In 2002, Mental Driller developed and released a virus that bridged the gulf
between metamorphic viruses and a new variety of viruses that could be called
&ldquo;genetic&rdquo;. MetaPHOR is a highly sophisticated metamorphic virus, capable of
infecting binaries on both Linux and Windows platforms. Written entirely in x86
assembly, it includes its own disassembler, intermediate pseudo-assembly
language, and assembler, as well as a complex metamorphic and encryption
engines. Its metamorphic engine mutates the code body through instruction
permutation, register swapping, 1-1, 1-2, and 2-1 translations of instructions
into semantic equivalents, and the injection of &rsquo;garbage code&rsquo;, or what we will
later call &ldquo;semantic introns&rdquo;.
</p>

<p>
But the final touch, which elevates this program to evolutionary status, is the
use of a simple genetic algorithm, which is responsible for weighting the
probabilities of each metamorphic transformation type. As Mental Driller
comments in the MetaPHOR source code:
</p>

<blockquote nil>
<p>
  I have added a genetic algorithm in certain parts of the code to make it
evolve to the best shape (the one that evades more detections, the action more
stealthy, etc. etc.). It&rsquo;s a simple algorithm based on weights, so don&rsquo;t expect
artificial intelligence :) (well, maybe in the future :P). 
</p>
</blockquote>

<p>
 The way it works is that each instance of the virus carries with it a small
gene sequence that represents a vector of weights &#x2013; one for each boolean
decision that the metamorphic engine will make when replicating and transforming
the virus, in the process of infection. These are modified a little with each
replication. The hope is that the selective pressure imposed by
antiviral software will select for strains of the virus that have evolved in
such a way as to favour transformations that evade detection, and shun
transformations that give the virus away. (Descendants of the virus, for
instance, may adapt in such a way as to never use decryption, if that should
turn out to the a tactic that attracts the scanners&rsquo; attention, in a given
ecosystem. Or they may evolve to be less aggressive in infecting files on the
same host, or filter their targets more carefully according to filename.
</p>

</section>
<section id="slide-orgf75453e">
<h4 id="orgf75453e"><span class="section-number-4">3.1.5</span> 2004-2005: W32/Zellome</h4>
<p>
The frequent invocation of ecological and evolutionary tropes in virus
literature, combined with the lack of any genuine appearance of evolutionary
malware, has led many to speculate as to its impossibility. The most frequently
cited reason
</p>

<p>
for the unfeasibility of viral evolution is <i>computational brittleness</i> &#x2013; the
claim being that the machine languages (or even scripting languages) that most
viruses are implemented in are relatively intolerant to random mutation. The
odds that a few arbitrary bitflips will result in functional, let alone
&rsquo;fitter&rsquo;, code is astronomically small, these critics reason. This is in
contrast to the instruction sets typically used in GP and ALife, which are
<i>designed</i> to be highly fault-tolerant and evolvable.
</p>


<p>
This is so far from being an insuperable obstacle that it suggests its own
solution: define a more robust meta-grammar to which genetic operators can be
more safely applied, and use those higher-level recombinations to steer the
generation of low-level machine code.
</p>

<p>
We can find this idea approximated in a brief article by ValleZ, appearing in
the 2004 issue of the vxer ezine, <i>29A</i>, under the title &ldquo;Genetic
Programming in Virus&rdquo;. The article itself is just a quick note on what the
author sees as interesting but in all likelihood impractical ideas:
</p>

<blockquote nil>
<p>
  I wanna comment here some ideas i have had. They are only ideas&#x2026; these ideas
seems very beautiful however this seems fiction more than reality. 
</p>
</blockquote>


<p>
ValleZ goes on to sketch out the main principles behind genetic programming, and
then gets to the crux of the piece: &ldquo;how genetic programming could be used in
the virus world&rdquo;.
</p>

<p>
As already noted, most of the essential requirements for GP are already present
in viral ecology: selective pressure is easy to locate, given the existence of
antiviral software, and replication is a given. However, ValleZ notes, the
descendant of a virus tends to be (semantically) identical to its parent, and
even when polymorphism or metamorphism are used, the core semantics remain
unchanged, and there is no meaningful accumulation of changes down generational
lines.
</p>

<p>
(Conjecture: If we were to picture the distribution of diversity in the
genealogy of a metamorphic virus, for instance, we would see a hub-and-spoke or
starburst design in the cluster, with no interesting progressions away from the
centre. Take a look at the Eigenvirus thesis to see if there&rsquo;s any corroboration
there.)
</p>

<p>
ValleZ suggests the use of genetic search operators &#x2013; mutation, and, perhaps,
in situations where viruses sharing a genetic protocol encounter one another in
the same host, crossover &#x2013; in virus replication. They would take over the work
that is usually assigned to polymorphic engine, with the added, interesting
feature of generating enough semantic diversity for selective pressures to act
on. But for this to work, they note, it would be necessary to operate not on the
level of individual machine instructions (which are, as noted, rather brittle
with respect to mutation) but higher-level &ldquo;blocks&rdquo;, envisioned as compact,
single-purpose routines that the genetic operators would treat as atomic.
</p>

<p>
The idea is left only barely sketched out, however, and ValleZ concludes by
reflecting that it seems more an idea &ldquo;for a film than for real life, however i
think its not a bad idea :-m&rdquo;.
</p>


<p>
In 2005, an email arrived in the inbox of the virus researchers Peter Ferrie and
Heather Shannon. Attached was a sample of what would go on to be known as the
W32/Zallome worm. The code of the worm appeared unweildly and bloated, but its
unusual polymorphic engine captured the analysts&rsquo; attention.
</p>

</section>
<section id="slide-org1c979db">
<h4 id="org1c979db"><span class="section-number-4">3.1.6</span> 2009: Noreen&rsquo;s experiment on grammatic malware evolution</h4>
<p>
At GECCO &rsquo;09, Sadia Noreen presented a report on her recent experiments
involving the evolution of computer viruses. The approach she adopted was to
first collect samples of several varieties of the Beagle worm (CARO name
W32/Bagle.{a,b,c,d,e}@mm), and then define a regular grammar that isolated the
separable components of each variant, and which could be used to recombine and
generate new variants. An initial population of grammatically correct, but
randomly generated, individuals would then be spawned.
</p>

<p>
The fitness function used in these experiments was, curiously, resemblance to
the existing samples, as judged by a distance metric and then ratified by an
antivirus scanner. The idea was that if an evolved specimen so closely resembled
the original samples they were indiscernibly to a scanner, than this would prove
that viruses <b>could</b> be generated using evolutionary techniques.
</p>

<p>
This isn&rsquo;t the most compelling use of evolutionary techniques in this realm &#x2013;
that random sets of parameters can be made to approximate or match a training
sample, when the fitness function depends precisely on the resemblance of the
former to the latter, is not surprising. Genetic algorithms are often introduced
through the use of &ldquo;hello world&rdquo; exercises posing formally similar problems. But
the framework that Noreen developed could, itself, be put to much more
interesting and creative ends, and the idea of assuring the evolvability and
mutational robustness of viral genotypes by defining and adhering to a strict
grammar is promising.
</p>

<p>
The idea of taking detection as a goal (in an effort to establish the
possibility of evolution in this context) rather than as an obstacle is a
strange approach, given that several scanners <b>also</b> use grammatical analysis to
detect the code (often limiting themselves to regular expressions and FSAs), and
so it&rsquo;s quite possible that the grammar itself went a long way towards
preserving the invariants that resulted in detection.
</p>

<p>
If the goal were to evolve viruses that had a chance of being viable in the
wild, and so had to contend with the selective pressures imposed by detectors,
the ideal approach would be to employ a grammar with greater Chomsky complexity,
as the virus writer known as &ldquo;Second Part to Hell&rdquo; points out in a 2008 post on
his website <a href="~/org/bibliography.bib::spth08">~/org/bibliography.bib::spth08</a>.
</p>

</section>
<section id="slide-org61f3a0d">
<h4 id="org61f3a0d"><span class="section-number-4">3.1.7</span> 2010-2011: Second Part to Hell: Evoris and Evolus</h4>
<p>
Second Part to Hell&rsquo;s experiments in viral evolution appear to be the most
sophisticated yet encountered. SPTH begins by identifying computational
fragility as the principal obstacle to the the evolvability of virus code as
implemented in x86 assembly. An obvious way to circumvent this problem, SPTH
reasons, is to have the genetic operators operate, not on the level of
architecture-specific opcodes, but on an intermediate language defined in the
virus&rsquo;s code itself.
</p>

<p>
SPTH designed his IL to be as highly-evolvable as possible, structured in such a
way that an arbitrary bit-flip would still result in a valid instruction, so
that they could be permuted or altered with little risk of throwing an
exception, and so that there would exist a considerable amount of redundancy in
the instruction set: 38 semantically unique instructions are defined in a space
of 256, with the remainder being defined as NOPs, affording a plentiful supply
of introns, should they be required.
</p>

<p>
&ldquo;The mutation algorithm is written within the code (not given by the platform,
as it is possible in Tierre or avida)&rdquo;, SPTH notes, referring to two well-known
Artificial Life engines. <a href="~/org/bibliography.bib::spth10a">~/org/bibliography.bib::spth10a</a>
</p>

<p>
The same is true of the IL syntax. In fact, what&rsquo;s particularly interesting
about this project, and with the problem of viral evolution in general, is that
the entire genetic machinery must be contained either in the organism itself, or
in features that it can be sure to find in its environment. In Evoris, the only
mechanism that remains external to the organism is the source of selective
pressure &#x2013; antivirus software and attentive sysadmins. Two types of mutation
are permitted with each replication: the first child is susceptible to bit flips
in its IL sequence, with a certain probability. With the second, however, the IL
instruction set may mutate as well, meaning that the virtual architecture itself
may change shape over the course of evolution. Interestingly, the first-order
mutation operators in the virus are themselves implemented with the viral IL,
and so a mutation to the alphabet &#x2013; one that changes the <code>xor</code> instruction to a
<code>nop</code>, for instance &#x2013; may, as a consequence, disable, or otherwise change the
functioning of, first-order mutation (as SPTH observed in some early
experiments).
</p>

<p>
Evolus extends Evoris to include a third type of mutation: &ldquo;horizontal gene
transfer&rdquo; between the viral code and files that it finds in its environment.
Since the bytes taken from those files will be interpreted in a language
entirely foreign to their source, there&rsquo;s no real reason to expect any useful
building blocks to be extracted, unless, of course, the Evolus has encountered
another of its kind, in which case we have something analogous to crossover.
(Horizontal gene transfer with an arbitrary file would then be analogous to
&ldquo;headless chicken crossover&rdquo;, with the random bytes being weighted to reflect
what the distribution found in the files from which the bytes are sourced.)
</p>

<p>
Though SPTH&rsquo;s results were fairly modest, the underlying idea of having the
virus carry with it its own language for genotype representation, and to take
cares to ensure the evolvability of that language &#x2013; and to expose the genetic
language itself to mutation and selective pressure &#x2013; is inspired, and turns
SPTH&rsquo;s experiments into valuable proofs of concept.
With them, at least two major obstacles to the use of evolutionary techniques
in the field of offence <b>have</b> been addressed and, to some extent, solved by the
vx community: the problem of code brittleness, or the viability of genetic
operators, and the problem of self-sufficiency (unlike academic experiments in
evolutionary computation, the virus must carry an implementation of the relevant
genetic operators with it everywhere it goes &#x2013; &ldquo;the artificial organisms are
not trapped in virtual systems anymore&rdquo;, SPTH writes, in the conclusion to the
first of his series of essays on Evoris and Evolus, &ldquo;they can finally move
freely &#x2013; they took the redpill&rdquo; (<a href="~/org/bibliography.bib::spth10a">~/org/bibliography.bib::spth10a</a>, 18).
</p>


</section>
<section id="slide-org17c6afd">
<h4 id="org17c6afd"><span class="section-number-4">3.1.8</span> Concluding remarks on the history of evolutionary techniques in virus programming</h4>
<p>
Interestingly, even in the virus scene, which is certainly where we find the
most prolonged and serious interest in evolutionary computation among black and
grey hat hackers, the uses to which evolutionary methods are put tend, for the
most part, to be fairly modest, and oriented towards defence (defending the
virus from detection). When genetic operators are employed, they tend to serve
as part of a polymorphic or metamorphic engine, and the force of selection
principally makes itself felt through antivirus and IDS software. 
Outside of science fiction <a href="~/org/bibliography.bib::xfiles-killswitch">~/org/bibliography.bib::xfiles-killswitch</a>, however, we have not seen any
discernable attempt to put evolutionary techniques in the service of malware that
<i>learns</i>, in a fashion comparable to what we see with next-generation defence
systems. There is nevertheless a tremendous amount of potential in this
direction, and the threat of unpredictable, evolving viral strains emerging from
this sort of research is one that hasn&rsquo;t failed to capture the imagination.
</p>

<p>
In a paper presented at the 2008 <i>Virus Bulletin</i> conference, two artificial
life researchers, Dimitris Iliopoulos and Christoph Adami, together with malware
analyst Péter Ször of Symantec, outline the threat that such technology may
pose and the extent to which it would be feasible to produce <a href="~/org/bibliography.bib::iliopoulos11">~/org/bibliography.bib::iliopoulos11</a>.
The greatest risk, it seems, concerns the possibility of detecting such malware.
Existing obfuscation techniques, they note, all share the same theoretical
limit: though polymorphic and metamorphic variants of a malware strain may evade
literal signature detection, and and syntactic/structural detection, they do
tend to share common <i>semantic</i> invariants, and remain vulnerable to detection
by means of a well-tuned behavioural profile. &ldquo;Simply put,&rdquo; they write,
</p>

<blockquote nil>
<p>
biological viruses are constantly testing new ways of exploiting environmental
resources via the process of mutation. In contrast, computer viruses do not
exhibit such traits, relying instead on changing their appearance to avoid
detection. <i>Functional</i> (as opposed to cryptic) variation, such as the discovery
of a new exploit or the mimicry of non-malicious behaviour masking malicious
actions, is not part of the arsenal of current malware. 
</p>
</blockquote>

<p>
Evolutionary techniques, by contrast, could allow for the generation of malware
instances whose semantic variation is bounded in extremely minimal, abstract,
and subtle fashions, as demanded by the task at hand, offering little to no
foothold for existing detection technologies. If allowed to develop more freely,
moreover, with no selective pressures beyond replication, survival, and the
subversion of the systems intended to stop them &#x2013; and if they could incubate
in environments where those particular pressures are gentle enough to allow for
relatively &ldquo;neutral&rdquo; (non-advantageous, but non-deleterious) exploration of their
environment &#x2013; then &ldquo;the emergence of complex adaptive behaviors becomes an
expected result rather than an improbability, as long as exploitable opportunities
exist within the malware&rsquo;s environment&rdquo; <a href="~/org/bibliography.bib::iliopoulos11">~/org/bibliography.bib::iliopoulos11</a>.
</p>

<p>
Sz&ouml;r, Iliopoulos, and Adami, here, are discussing the use of evolutionary
techniques in virus generation, rather than payload generation, as examined
in this thesis &#x2013; and, indeed, as we&rsquo;ll see, despite the relative dearth of concrete
advancements, the theme of evolutionary computation has been a preoccupation
of virus writers ever since the first computer virus was crafted, a phenomenon
we don&rsquo;t see paralleled in other fields of offensive/counter-security. There
are challenges facing the deployment of evolutionary malware &ldquo;in the wild&rdquo; that
we don&rsquo;t encounter when developing it &ldquo;in vitro&rdquo; &#x2013; that is to say, in a virtual
laboratory, where selective pressures can be fine-tuned with care, rather than
left to external circumstance. Where the research presented here rejoins
Sz&ouml;or, Iliopoulos, and Adami&rsquo;s anticipations is in examining the results of
relatively free and unconstrained exploration of a host environment by
evolutionary malware, where the tether to semantic invariance is intentionally
kept as loose as possible and the specimens have the ability to salvage and
recombine whatever functional code they can from their hosts. This is, after
all, the very nature of a &ldquo;code reuse&rdquo; or &ldquo;data-only&rdquo; attack &#x2013; terms often
given to rop in the literature &#x2013; a quality that makes them an especially
appealing subject for evolutionary study. It should nevertheless be emphasized
that we are <i>not</i> engineering <i>viral</i> malware here &#x2013; \gls{roper}&rsquo;s populations
are not capable of <i>self</i>-replication, and do not encapsulate their own genetic
operators. For that, they rely on the roper engine. Once generated, they
can certainly be <i>deployed</i> in the wild, but we do not expect any such specimens
to be capable of reproduction, there, and so their evolutionary history ends
as soon as they exit the incubator.
</p>

<p>
The historical lineage that comes closest to what we are doing here, then, is
what we could call <i>evolutionary payload generation</i>. 
This lineage is considerably shorter &#x2013; we see no comparable fascination with
evolutionary techniques in the exploit-writing world, as compared to the vx
scene &#x2013; but the achievements that have been made in this direction tend to be
considerably more robust, in terms of evolutionary computation. The most likely
reason for this is simply that payload evolution &#x2013; where the malware is <i>produced</i>
using genetic techniques, but is not expected to <i>continue</i> evolving once &ldquo;released&rdquo;
&#x2013; is amenable to laboratory study, and to rapid iterations of the evolutionary cycle,
in a way that virus crafting is not. 
</p>


</section>
<section id="slide-org590e685">
<h3 id="org590e685"><span class="section-number-3">3.2</span> Genetic Payload Crafting</h3>
<div class="outline-text-3" id="text-3-2">
</div>
</section>
<section id="slide-org2d1dd06">
<h4 id="org2d1dd06"><span class="section-number-4">3.2.1</span> Gunes Kayacik and the evolution of buffer overflow attacks</h4>
<p>
Gunes Kayacik&rsquo;s 2005-2011 research (see <a href="~/org/bibliography.bib::kayacik06">~/org/bibliography.bib::kayacik06</a>, <a href="~/org/bibliography.bib::kayacik10">~/org/bibliography.bib::kayacik10</a>, and <a href="~/org/bibliography.bib::kayacik11">~/org/bibliography.bib::kayacik11</a>, for instance)
brought evolutionary methods &#x2013; specifically,
linear genetic programming (LGP) and grammatical evolution (GE) &#x2013; to bear on
the problem of automatically generating shellcode payloads for use in the sort
of buffer overflow attacks already known to us from Aleph One. The aim of that
research is twofold:
</p>

<ol>
<li>it aims to evolve payloads that can evade not just
rudimentary signature-based detection engines, like Snort&rsquo;s, monitoring
inbound packets, but also anomaly-detecting, host-based intrusion detection
systems, such as Process Homeostasis (pH). In this respect, it has much in
common with the uses of genetic algorithms that we start to see in some of
the more experimental corners of the virus scene, in the early years of the
millenium. In fact, the principal means of obfuscation that Kayacik saw
emerging from his attack population was the proliferation of &ldquo;introns&rdquo;, or
what the virus literature refers to as &ldquo;garbage code&rdquo; when discussing an
analogous tactic of metamorphic engines.</li>

<li>the secondary aim of Kayacik&rsquo;s research, however, is to use
these evolving shellcode specimens to better train the same defensive AIs
that the population of attacks is struggling to subvert. The ideal, here, is
to lock both intelligences into an evolutionary arms race. In practice,
however, the attack populations had little difficulty leaving the defenders
in the dust.</li>

</ol>

<p>
Kayacik&rsquo;s research was one of the initial inspirations for the current project,
and remains one of the very few serious attempts to put evolutionary methods to
work in the domain of offensive cybersecurity. I was quite surprised to find &#x2013;
or, rather, fail to find &#x2013; any significant research by others, continuing in this
vein, after 2011. 
</p>

</section>
<section id="slide-orgb7c4de1">
<h3 id="orgb7c4de1"><span class="section-number-3">3.3</span> The Road Ahead</h3>
<p>
Despite the relative dearth of work being done on the intersection of exploit
research and evolutionary computation &#x2013; an intersection which is all but
barren, though flanked by thriving research communities on both sides &#x2013; it is
our conviction that this may become extraordinarily fertile terrain for
research. Evolutionary methods are naturally well-suited to the exploration of
the possibility space inhabited by weird machines. This is not least due to the
fact that such machines, whose existence is an emergent and altogether
accidental effect, are in no way designed to be hospitable to human programmers.
Even the most obtuse and ugly programming language &#x2013; including the tiramisu of
backwards-compatible ruins that makes up the x64_64 &#x2013; is designed with <i>some</i>
aspiration of cognitive tractability and elegance in mind. As much as it may
<i>seem</i> that this or that programming environment cares little for the
programmer, this is never truly the case &#x2013; until you enter the terrain of weird
machines. These are landscapes that were never intended to exist in the first
place &#x2013; they&rsquo;re a wilderness supervening on artifice.
</p>

<div>
\begin{savequote}
\textbf{The Roper:} This monster appears to be a mass of foul, festering corruption.
\qauthor{\emph{The Strategic Review}, Vol. 1, No. 2 (Summer, 1975)}
\end{savequote}

</div>
</section>
</section>
<section>
<section id="slide-org202bfc5">
<h2 id="org202bfc5"><span class="section-number-2">4</span> On the Design and Implementation of ROPER: Algorithmic Overview</h2>
<p>
<a id="org765e5dc"></a>
<a id="orgf11bfdc"></a>
</p>

<p>
What we will establish in the pages that follow is that it is
indeed possible to generate functioning, rop chain payloads
through purely evolutionary techniques. By &ldquo;purely evolutionary&rdquo;,
here, we mean that payloads are to be evolved <i>from scratch</i>,
starting with nothing but a collection of gadget pointers, of
which we have virtually no semantic information, and a pool of
integer values. This stands in contrast to
most previous experiments in the field of offensive
security, where the role of evolutionary techniques is restricted
to the fine-tuning or obfuscation of already existing malware
specimens
or to the recombination of high-level modules into working
programs, following an established pattern.
</p>

<p>
By &ldquo;functioning&rdquo;, we mean only that we are able to generate
ROP payloads that reliably perform to specification, for a wide
variety of tasks. Some of these tasks are simple and exact
&#x2013; such as preparing the cpu context for a given system call,
with certain parameters &#x2013; whereas others are complex but
vague in nature &#x2013; tasks concerning the classification of data
by implicit properties, or interacting with a dynamic environment.
In each case, <i>all</i> that is provided to our system by way of
instruction are the specifications of the task, translated into
selective pressures in the form of a &ldquo;fitness function&rdquo;.
</p>

<p>
It should be emphasized that this system, acronymously named roper, is
presented as a <i>proof of concept</i>, and not as a refinement of evolutionary
techniques. roper is far from being an impressively efficient compiler or
classifier, and no attempt was made to have it be otherwise. What roper is, is
the first known use of evolutionary computation in return oriented programming,
and, more generally, the first time that genetic programming has been put to
work at a task for which it seems so obviously suited: the autonomous
programming of state machines that emerge entirely by accident, supervening on
the systems we designed, without our having ever designed them, and having
languages and instruction sets all their own, without having ever been
specified, spontaneously coalescing in the cracks of our abstractions.
</p>


<div id="org7fcf0bc" class="figure">
<p><img src="../images/birdseye.png" alt="birdseye.png" />
</p>
<p><span class="figure-number">Figure 1: </span>A bird&rsquo;s eye view of roper</p>
</div>


<div>
\begin{algorithm}
\caption{Population Initialization}
\label{alg:initpop}
\begin{algorithmic}[1]
\REQUIRE $\varepsilon$, ELF binary of the process to be attacked
\REQUIRE $\pi$, the problem set specification
\REQUIRE $n$, the desired population size
\REQUIRE $\iota$, a pool of raw integers
\REQUIRE $(\frak{R},s)$, a pseudo-random number generator and seed
\STATE {text, rodata $\gets$ parse($\varepsilon$)}
\STATE {$\iota$ $\gets$ $\iota$ $\cup$ find-pointers(rodata, $\iota$)}
\STATE {$\gamma \gets$ harvest-gadgets(text)}
\STATE {$\Pi \gets$ empty-vector($n$)}
\STATE {$\frak{R}$ $\gets$ seed($\frak{R},s$)}
\FOR {$x \gets 1 $ \TO $n$}
\STATE {$\frak{R}$, $\Pi_x$ $\gets$ 
        spawn-individual($\frak{R}$, $\gamma$, $\iota$, rodata)}
\label{alg:initpop:line:spawn-individual}
\ENDFOR
\RETURN population
\end{algorithmic}
\end{algorithm}

</div>


<div>
\begin{algorithm}
\caption{Genotype Evaluation (Ontogenesis)}
\label{alg:evalgen}
\begin{algorithmic}[1]
\REQUIRE $E$, the CPU emulator
\REQUIRE $IO: [(in, out, weight)]$, the input/output rules for the problem set
\REQUIRE $\varphi: [\mathbb{N}] \rightarrow \mathbb{F}$, 
\REQUIRE \texttt{SENTINEL}: uint, a fixed-width integer constant (0, e.g.)
\REQUIRE $\mu$: $\mathbb{N}$, the maximum number of execution steps permitted
the fitness function, mapping vectors of integers to floats
\REQUIRE $\Gamma$, the genotype to be evaluated
\STATE {$\sigma \gets $ serialize($\Gamma$) $\cup$ [SENTINEL]}  \COMMENT {\emph{into a stack of bitvectors}}
\STATE {accumulator $\gets$ ()}
\FORALL {case in $IO$}
\STATE {$E$ $\gets$ prime $E$ with case.in}
\STATE {$E$ $\gets$ load $\sigma$ into stack memory of $E$}
\STATE {$E$ $\gets$ exec($E$, \texttt{"POP PC, SP"})} \COMMENT {\emph{pop stack into program counter}} 
\STATE {$i \gets 0$}
\WHILE {$i < \mu$ \AND program-counter($E$) $\neq$ SENTINEL \AND in-legal-state($E$)}
\STATE {$E \gets$ step($E$)} \COMMENT {\emph{fetch instruction at }\texttt{PC}\emph{ and execute}}
\STATE {$i \gets i+1$}
\ENDWHILE
\STATE {accumulator $\gets$ acc(accumulator, case.weight, $\varphi$(read-registers($E$), case.out))}
\STATE {$E$ $\gets$ reset($E$)}
\ENDFOR 
\RETURN {accumulator} \COMMENT {\emph{the `phenotype'}}
\end{algorithmic}
\end{algorithm}

</div>

<div>
\begin{algorithm}
\caption{Evolve Population (Tournament Selection)}
\label{alg:evolve}
\begin{algorithmic}[1]
\REQUIRE $\Pi$, the population \COMMENT {\emph{as initialized by Algorithm~\ref{alg:initpop}}}
\REQUIRE $E$, the CPU emulator
\REQUIRE $\Omega: \Pi \rightarrow \mathbb{B} $, the stop condition (predicate over $\Pi$)
\REQUIRE $\Sigma$, the problem set
\REQUIRE $(\frak{R}, s)$, a PRNG and seed
\REQUIRE $n$, the number of individuals competing in each selection tournament
\STATE {$\frak{R}$ $\gets$ seed($\frak{R}, s$)}
\REPEAT
\STATE {$\frak{R}$, candidates $\gets$ using $\frak{R}$, pick $n$ from $\Pi$}
\label{alg:evolve:line:candidates}
\STATE {$\Phi \gets $ empty list of (float, genotype) pairs}
\FOR {$\Gamma$ in candidates} 
\STATE {$\Gamma_\textit{fitness}$ $\gets$ evaluate-genotype($\Gamma, \Sigma, E$)}
\COMMENT {\emph{Algorithm~\ref{alg:evalgen}}}
\ENDFOR
\STATE {$\Phi \gets$ sort($\Phi$, by \emph{fitness})}
\STATE {victors $\gets$ take $m$ from $\Phi$}
\STATE {vanquished  $\gets$ take $k$ of reverse($\Phi$)}
\STATE {$\frak{R}, \textrm{offspring}_{1\dots k} \gets \textit{breed}(\frak{R}, k, \textrm{victors})$}
\label{alg:evolve:line:breed}
\STATE {$\Pi \gets [\textrm{vanquished/offspring}]\Pi$} \COMMENT {replace vanquished with offspring}
\UNTIL {$\Omega(\Pi) = \TRUE$}
\STATE {champion $\gets$ head(sort($\Pi$, by \textit{fitness}))}
\RETURN {champion}
\end{algorithmic}
\end{algorithm}

</div>

<p>
Algorithms \ref{alg:initpop}, \ref{alg:evalgen}, and \ref{alg:evolve}
furnish a bird&rsquo;s eye view of roper, abstracting away from questions of
implementation, and streamlining away various bits of functionality
aimed at optimization, bookkeeping, and fine-tuning.
</p>

<p>
roper begins with the analysis of an executable binary file (either an
application or a library). For the time being, we are restricting
ourselves to binaries targetting the 32-bit armv7 architecture, in ELF
format, but there is nothing essential about this restriction, and
roper could easily be extended to handed a variety of hardware
platforms and executable formats, if desired. It harvests as many viable
ROP gadgets as it can from the file (within parameterizable limits), by 
means of a linear sweep search, walking backwards through the file&rsquo;s
executable <code>.text</code> section until it hits a return instruction, and then
walking further backwards until it reaches an instruction that would
prevent the execution flow from reaching the return. This isn&rsquo;t the
most thorough or exacting technique for finding gadgets, and a wider
variety of potentially usable gadgets can be uncovered by means of
a constraint-solving algorithm, which is able to detect stack-controllable
indirect jumps other exploitable control-flow artefacts as well. (We experiment
with such an approach in roper II, which is still in progress at the time of
writing.) A linear sweep nevertheless suffices to provide us with a fairly
generous number of gadgets for our purposes, and has the advantage of being
both simple and efficient.
</p>

<p>
The addresses of these gadgets, together with a pool of potentially useful
immediate integer values and data pointers, which can be supplied by the
user, or inferred from the specification of the problem set, supply us with
the primtive genetic units from which the first genotypes in the population will
be composed. With no more abuse of terminology than is customary in evolutionary
computation, we can call this the &ldquo;gene pool&rdquo; of the population. It should
nevertheless be noted that the biological concept of <i>gene</i> presupposes many
structural constraints that have, as of yet, no parallel in our system.
</p>

<p>
The initial population, as yielded by Algorithm \ref{alg:initpop}, is
little more than an array of variable-length vectors of fixed-width
integers (32-bits, so long as we are restricting ourselves to the
armv7, but, again, this restriction matters little so far as the
system&rsquo;s algorithmic structure is concerned). The length of the
initial individuals is left parameterizable, but is upper-bounded by
the amount of stack memory that will be available in the target
process for our attacks to write to. We will complicate this structure
somewhat, in Section <a href="#/slide-org9fe9149">4.2</a>, but it remains a useful
simplification.
</p>

<p>
The main loop, outlined in Algorithm \ref{alg:evolve}, is built around a
well-known and widely used genetic programming algorithm called &ldquo;tournament
selection&rdquo;. On each iteration of the loop, \(n\) (typically 4) distinct candidate
genotypes are chosen from the population, with equal probability. Each is then
mapped to its phenotype (its behavioural profile in the emulated cpu), and its
fitness evaluated (by applying the fitness function to that profile). The \(m\) 
(typically 2) candidates with the best fitness are selected for reproduction,
while the least-fit \(k\) candidates are culled from the population. 
</p>

<p>
The genotypes selected for reproduction are then passed to our genetic operators,
which will return \(k\) offspring, who will replace the least-fit \(k\) candidates
in the tournament. In the genetic programming literature, these operators are
often referred to as the &ldquo;search operators&rdquo;, as they &ldquo;define the manner in which
the system moves through the space of possible solutions&rdquo; (<a href="~/org/bibliography.bib::banzhaf98">~/org/bibliography.bib::banzhaf98</a>, 144).
In roper, our genetic operators comprise a single-point crossover function,
which maps a pair of parents into a pair of offspring, and a mutation operator,
which maps a single genotype into a variant thereof. The internals of these
operators are detailed in Section <a href="#/slide-org70d32af">4.3</a>.
</p>

<p>
This loop continues until the halting conditions are satisfied. These are most
often set either to a maximum number of iterations, or the attainment of a set
degree of fitness by the population&rsquo;s fittest specimen.
</p>

<p>
In the following sections, we will explain the finer-grained design decisions
involved in implementing the algorithms specified above. 
</p>

<p>
In the following sections, I will unfold and justify the decisions that went into
implementing the algorithms surveyed in Section <a href="#/slide-orgf11bfdc">4</a>.
We can begin with the representation of the genotypes constructed by
the <b>spawn-individual()</b> algorithm, called on line
\ref{alg:initpop:line:spawn-individual} of Algorithm \ref{alg:initpop}.
</p>

</section>
<section id="slide-org3c76d0b">
<h3 id="org3c76d0b"><span class="section-number-3">4.1</span> Gadget Extraction</h3>
<p>
<a id="orgc6a9d60"></a>
</p>

<p>
Since the aim of roper is to foster the evolution of ROP chains, we 
must begin by supplying the engine with a sufficient pool of gadgets, 
harvested from the target executable. 
  <sup><a id="fnr.11" class="footref" href="#fn.11">11</a></sup>
</p>

<p>
There are several ways that this can be done, but the simplest is just to
scan the executable for a subset of easily recognizable &rsquo;gadgets&rsquo; using a
linear sweep algorithm, shown in Algorithm \ref{alg:rop-sweep}. Since we are
dealing only with a RISC instruction set architecture here, we can avoid 
several complexities in our gadget search that we would need to grapple with
were we adapting roper to handle CISC instruction sets (such as the x86 and
its ilk) as well. The instructions of a RISC ISA are all of equal length
(with a certain exceptions, and assumping the mode fixed), and so if a
sequence of bytes beginning at address \(i\) is parsed as instruction \(X\)
when beginning the parse <i>from</i> \(i\), then it will also be parsed as \(X\)
when beginning the parse from some \(j < i\). To put it another way, the
list of RISC instructions parsed from bytevector \(\mathbf{C}\), beginning
at address \(i\), extends <i>monotonically</i> with each decrement of \(i\).
In practical terms, this means that an instruction that looks like a
return from far away will still look like a return by the time you&rsquo;ve parsed your
way up to it. This is very different from what we encounter with CISC ISAs,
where the length of instructions is variable, and instructions are not aligned.
Suppose we had the string <code>"aabbcc"</code> of bytes. Suppose that <code>aa</code> parses to
&alpha;, <code>ab</code> parses to &beta;, <code>bb</code> parses to &tau;, <code>cc</code> parses to &delta; and
<code>bcc</code> parses to &gamma;. If we begin the parse from the beginning of the string,
we get \(\alpha \tau \delta\). But if we increment our cursor one byte forward
before parsing, then our parse yields \(\beta \gamma\), with &delta; nowhere
to be seen. In order to adapt our gadget harvesting algorithm to CISC ISAs,
therefore, we would have to continually check to ensure that the <b>return</b>
instruction spotted at line \ref{alg:rop-sweep:line:see-ret} of
Algorithm \ref{alg:rop-sweep} is still parseable as a return, and still reachable, from
the address indicated by \(i\) on line \ref{alg:rop-sweep:line:storegadget}. This
would increase the complexity of the algorithm substantially. 
</p>

<p>
Fortunately, for the time being, we are concerned only with the two main instruction
sets of the armv7: the <i>arm</i> instruction set, which is aligned to four-byte intervals, 
and the <i>thumb</i> instruction set, which is aligned to two-byte intervals. A sufficient
supply of gadgets can usually be found by passing our extraction algorithm twice
over the executable segments of our target binary, gathering a pool of both <i>arm</i>
and <i>thumb</i> gadgets. Since the least significant bit of an instruction address is
invariably 0, for this ISA, the arm cpu uses this bit to distinguish between <i>arm</i>
mode and <i>thumb</i> mode. We therefore increment the address of each of our freshly
harvested thumb gadgets by 1.
</p>



<div>
\begin{algorithm}
\caption{Linear sweep algorithm for gadget extraction.}
\label{alg:rop-sweep}
\begin{algorithmic}[1]
\REQUIRE {$\mathbf{C}$: a contiguous vector of bytes representing instructions}
\REQUIRE {$\ulcorner{X_j}\urcorner: [\mathbf{byte}] \rightarrow \mathbb{N} \rightarrow \textrm{inst}|\Lambda$,
a parsing function, from byte-vectors $X$ and indices $j$ to instructions, or $\Lambda$ in
case of unparseable bytes.}
\REQUIRE {$\rho: \textrm{inst} \rightarrow \mathbb{B}$, predicate to recognize returns}
\REQUIRE {$\varphi: \textrm{inst} \rightarrow \mathbb{B}$, predicate to recognize control instructions,
with $\forall(x)~\rho(x)\Rightarrow\varphi(x)$, but not necessarily the converse. $\varphi$ should
also return \textbf{true} for $\Lambda$ (signalling unparseable bytes).}
\REQUIRE {$\delta$: positive integer,  offset of base virtual address for $\mathbf{C}$}
\STATE {$\Gamma \gets$ empty stack of integers}
\STATE {$i \gets $ length($\mathbf{C}$)}
\WHILE {$i > 0$}
  \STATE {$i \gets i - 1$}
  \IF {$\rho(\ulcorner\mathbf{C}_{i+1}\urcorner)$} \label{alg:rop-sweep:line:see-ret}
    \WHILE {$\neg \varphi(\ulcorner\mathbf{C}_i\urcorner)$ \AND $i > 0$}
      \STATE {push $i$ onto $\Gamma$} \label{alg:rop-sweep:line:storegadget}
      \STATE {$i \gets i - \textrm{length}(\ulcorner\mathbf{C}_i\urcorner)$}
    \ENDWHILE
  \ENDIF 
 \ENDWHILE
\STATE {$\Gamma^\star \gets \textrm{map~}(\lambda x. \delta + x) \textrm{ over } \Gamma$}      
\RETURN {$\Gamma^\star$}
\end{algorithmic}
\end{algorithm}

</div>

</section>
<section id="slide-org1c2b269">
<h3 id="org1c2b269"><span class="section-number-3">4.2</span> Genotype Representation: Gadgets, Clumps, and Chains</h3>
<p>
<a id="org9fe9149"></a>
\label{sec:clumps}
</p>

<p>
From a certain perspective &#x2013; that of the evaluation engine &#x2013; the individual
genotypes of the population are little more than bare ROP-chain payloads:
vectors of 32-bit words, each of which is either a pointer into the executable
memory of the host process, or raw data (the former being a subtype of the
latter, of course). The view afforded to the genetic operators, and to the
initial spawning algorithm, exposes slightly more structural complexity,
which is introduced in response to the following problem:
</p>

<p>
In the set of 32-bit integers (\(\texttt{0x100000000}\) in all), the subset representing
the set of pointers into the executable memory segments of a given ELF file
tends to be rather small: in the case of <code>tomato-RT-N18U-httpd</code>, an HTTP
server that ships with a version of the Tomato firmware for certain arm
routers, which we will be using for a few of the experiments that follow,
we can see that only \(\texttt{0x1873c} + \texttt{0xc0} = \texttt{0x187ec}\) bytes are mapped to executable
memory. Now, the armv7 cpu is capable of running in two different modes, each
with their own instruction set: <i>arm</i> mode, which requires the instructions to
be aligned to 4-byte units, and <i>thumb</i> mode, which demands only a 2-byte alignment
of instructions. Since the least significant bit in a dword can therefore not be
used to differentiate between instruction addresses, the armv7 cpu uses it to
distinguish between the two modes: any address \(a\) whose least significant bit is 1
(i.e., any odd-valued address) is dereferenced to a thumb instruction
at address \(a \oplus 1\) (rounding down to the nearest even address). 
This gives us a total of \(\frac{\texttt{0x187ec}}{4} + \frac{\texttt{0x187ec}}{2} = \texttt{0x125f1}\) valid
executable pointers &#x2013; which, roughly, means that only one in fifty-thousand
of integers between <code>0x00000000</code> and <code>0xFFFFFFFF</code> can be dereferenced to executable
memory in a the ELF executable in question &#x2013; a ratio that is seldom increased
by more than one or two orders of magnitude, even when dealing with large,
statically linked ELF binaries.
  <sup><a id="fnr.12" class="footref" href="#fn.12">12</a></sup>
</p>

<div>
\begin{table}
\scriptsize
\caption{Program Headers of a Typical ELF Executable}
\label{tab:readelf-tomato}
\hrule
\begin{verbatim}
$ readelf --program-headers tomato-RT-N18U-httpd

Elf file type is EXEC (Executable file)
Entry point 0xa998
There are 6 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x00008034 0x00008034 0x000c0 0x000c0 R E 0x4
  INTERP         0x0000f4 0x000080f4 0x000080f4 0x00014 0x00014 R   0x1
      [Requesting program interpreter: /lib/ld-uClibc.so.0]
  LOAD           0x000000 0x00008000 0x00008000 0x1873c 0x1873c R E 0x8000
  LOAD           0x01873c 0x0002873c 0x0002873c 0x0040c 0x005c8 RW  0x8000
  DYNAMIC        0x018748 0x00028748 0x00028748 0x00118 0x00118 RW  0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn 
          .rel.plt .init .plt .text .fini .rodata .eh_frame 
   03     .init_array .fini_array .jcr .dynamic .got .data .bss 
   04     .dynamic 
   05     
\end{verbatim}
\hrule
\end{table}

</div>

<p>
This means that if we allow the integers composing the genotypes of our
initial population to be randomly selected from the entire 32-bit range,
only a tiny fraction of those integers will dereference to any meaningful
executable addresses in the code &#x2013; let alone useful gadget addresses.
Restricting the pool of integers sampled to the set of valid executable 
pointers, let alone potentially useful gadget points, however, may deprive
the population of useful numerical values. 
</p>

<p>
The execution of these individuals, after all, will be driven by return
instructions, and these, in arm machine code, are most often implemented as
multi-pops, which pop an address from the stack into the program counter, while
simultaneously popping a variable number of dwords into other, general-purpose
registers. This means that each <code>return</code> &#x2013; each &ldquo;tick&rdquo; of the ROP state-machine
&#x2013; not only steers the control flow of our machine, sending it to a new gadget,
but the data flow as well, furnishing each gadget with a handful (between zero
and a dozen) of numerical values, to use internally. We don&rsquo;t necessarily want
to restrict these numerical resources to the range of gadget pointers &#x2013; it would
be better, in fact, if we could tailor the pool of &ldquo;potentially useful&rdquo; numerical
values to a set of integers (including, perhaps, data pointers) that seems suited
to the problem set at hand. 
</p>

<p>
This suggests a potentially useful structural constraint that we can
impose on the genotypes, to increase the likelihood that they will be found
useful for the problem space at hand, and greatly increase the probability that
<code>.text</code> pointers will be popped into pc, while other integers
integers land predominantly in general-purpose registers.
To do this, we calculate the distance the stack pointer will shift
when each gadget executes, the \gls{spd} of \(g\) or \(\gls{spd}(g)\), and then clump together
each gadget pointer \(g\) with a vector of \(\gls{spd}(g)-1\) non-gadget
values. Consider, for example, the instruction,
\[\mathtt{LDMIA!~~~~SP,~~\{R0, R7, R9, PC\}}\]
which pops the stack into registers <code>R0</code>, <code>R7</code>, <code>R9</code>, and pc, in sequence,
&ldquo;returning&rdquo; the program counter to the address represented by the fourth dword
on the stack, while at the same time populating three general purpose registers
with the stack&rsquo;s first three dwords. This instruction has a \(\gls{spd}\)
of 4. For a gadget \(g\), we define \(\gls{spd}(g)\) as 
\[\gls{spd}(\pi) = \sum_{i\in \pi} \gls{spd}{i}\]
for some control path \(\pi\) in \(g\) that reaches the return. In practice,
we choose our initial pool of gadgets in such a way that each contains only a basic
block of code, with control flow entirely in the hands of the return instruction
that terminates it, so that the choice of \(\pi\) is unique for each \(g\). If this
condition is relaxed, we suggest generating \(n\) distinct clumps for each
distinct member of \(\{\gls{spd}(\pi)|\pi \textit{ is a control path in } g\}\).
Exactitude isn&rsquo;t strictly necessary, here, however &#x2013; as we&rsquo;ll see, the
evolutionary process that follows is robust enough to handle a fairly large
number of gadgets with miscalculated \(\gls{spd}\) values. A good rule of thumb,
here, is that when the approximation of \(\gls{spd}(g)\) is left inexact, in the
interest of efficiency, dump several options into the pool, and let natural
selection sort them out.
</p>

<p>
Given a gadget entry point address \(\addr{g}\), a &ldquo;clump&rdquo; around \(g\) can now be
assembled by taking a stack of \(\gls{spd}(g)-1\) arbitrary values, and pushing
\(\addr{g}\) on top of it. By the time \(g\) has run to completion, it will have popped
\(\gls{spd}(g)\) values from the process stack. The first \(\gls{spd}-1\) of
these will populate the general purpose registers of the machine, and the
\({\gls{spd}}^{\textit{th}}\) will pop the entry point of the <i>next</i> gadget,
\(g'\), into <code>pc</code>. That entry point, \(\addr{g'}\) will be found at the top of the
next clump in the sequence that makes up the genotype.
  <sup><a id="fnr.13" class="footref" href="#fn.13">13</a></sup>
</p>

<p>
As explained in Section <a href="#/slide-orgfe77228">2.2.2</a>, it is often helpful to think of
each gadget as an instruction in a virtual machine &#x2013; an emergent machine,
supervening on the host&rsquo;s native instruction set architecture. What we&rsquo;re
calling a clump here maps onto this concept of &ldquo;instruction&rdquo;, but with a
slight displacement: the gadget address can be seen as something
like an &ldquo;opcode&rdquo; for the rovm, and the immediate values in each clump
can be seen as operands &#x2013; <i>but operands of the next instruction</i>, not of
the instruction whose opcode is represented by their own clump&rsquo;s gadget
pointer.
</p>

<p>
When the initial population is generated, we take a pool of gadget pointers, 
harvested from the target binary (see Section <a href="#/slide-orgc6a9d60">4.1</a>), and a
pool of integers and data pointers, supplied by the user as part of the problem
specification. We then form clumps, as described above, using randomly chosen
elements of these two pools, as needed. The clumps are then assembled into 
variable length chains (with the minimum and maximum allowed lengths being
parameterized by the user), which gives us our genotype representation. The
internals of this algorithm are detailed in Algorithm&nbsp;\ref{alg:spawn}.
</p>

<div>
\begin{algorithm}
\caption{Spawning an Initial Individual}
\label{alg:spawn}
\begin{algorithmic}[1]
\REQUIRE $\mathbf{G}: [\![\mathbb{N}^{\,32}]\!]$, a set of gadget pointers
\REQUIRE $\mathbf{P}: [\![\mathbb{N}^{\,32}]\!]$, a set of integers and data pointers
\REQUIRE $(\mathfrak{R}, s)$: a PRNG and seed
\REQUIRE $(min, max): (\mathbb{N}, \mathbb{N})$, minimum and maximum genotype lengths
\STATE {$\Gamma \gets $ empty stack of clumps} \COMMENT{\emph{the genotype representation}}
\STATE {$\mathfrak{R} \gets $ seed$(\mathfrak{R},s)$}
\STATE {$n, \mathfrak{R} \gets $ random-int($\mathfrak{R}$, min, max)}
\FOR {$i \gets 0$ to $n$}
  \STATE {$\addr{g}, \mathfrak{R} \gets $ choose$(\mathfrak{R}, \mathbf{G})$}
  \STATE {$C \gets $ empty stack of $\mathbb{N}^{\,32}$}
  \STATE {$\delta \gets \gls{spd}(g)$}
  \COMMENT {\emph{cf. sec. \ref{sec:clumps} for def. of $\gls{spd}$}}
    \FOR {$j \gets 0$ to $\delta$} 
      \STATE {$p, \mathfrak{R} \gets $ choose$(\mathfrak{R}, \mathbf{P})$}
      \STATE {push $p$ onto $C$}
    \ENDFOR
    \STATE {push $\addr{g}$ onto $C$}
  \STATE {push $C$ onto $\Gamma$}
\ENDFOR
\RETURN {$\Gamma$}
\end{algorithmic}
\end{algorithm}

</div>

</section>
<section id="slide-org599747e">
<h3 id="org599747e"><span class="section-number-3">4.3</span> Genetic Operators</h3>
<p>
<a id="org70d32af"></a> 
</p>

<p>
In order for our population of loosely structured but otherwise random
ROP chains to explore the vast and uncharted space of possible combinations
and (on the side of phenotypes) their associated behaviours, we need a
means of moving from a given subset of our population to &ldquo;similar&rdquo; genotypes
in the neighbourhood of that subset, which may not yet belong to the population.
This is accomplished by the genetic operators, which allow our population to
search the genotype space through reproduction and variation.
</p>

<p>
roper makes use of two such operators: a crossover operator, which operates 
on genotypes as lists of clumps, and a mutation operator, which operates on
clumps internally. 
</p>

</section>
<section id="slide-orgeab81fe">
<h4 id="orgeab81fe"><span class="section-number-4">4.3.1</span> Mutation</h4>
<p>
     <a id="org6a0db08"></a>
The mutation operator selects, randomly, from a set of transformations,
which it then applies to one or more words contained in one or more randomly
selected clumps. The choice of operation is constrained by the word slot being
operated on: the word that is (probabilistically) fated to be loaded into the
instruction pointer isn&rsquo;t subject to the same range of modifications that the
other words in the clump are. The reason for this is that the performance of an
individual will, in general, be more sensitive to modifications to its gadget
pointers than to its immediate values, and so it makes sense to afford the
mutation operator a greater degree of freedom when dealing with a value that is
unlikely to be used to directly control the instruction pointer. It is
relatively safe to increment or decrement a pointer by a word size or two, but
almost always hazardous to negate or shift it, for example.
</p>

<p>
The rest of the words in the clump can be mutated much more freely. The
operations currently available include:
</p>

<ol>
<li>arithmetically, by applying either numerical operations such as addition and
subtraction;</li>
<li>bitwise operations, such as shifts, rotations, sums, and products by
a randomly selected constant value;</li>
<li>the pointer operations of dereference (interpreting a value as a pointer,
when possible, and replacing it with the value found at the corresponding
address in the process&rsquo;s memory) and indirection (the somewhat more
costly (\(O(n)\) over the size \(n\) of the memory space) operation of
searching through memory for an instance of the value, and replacing
it with a pointer that dereferences to it). When a value cannot be
dereferenced as a pointer, or a pointer to a word cannot be found in
memory, the operation collapses to the identity function;[fn::
Putting \(\&\) for raw indirection and \(*\) for raw dereference, as in C,
our pointer operators \(\&'\) and \(*'\) are defined as endomorphisms in
\(\mathbb{2}^{32}\), where \(\&'(x) = \&x\) when \((\exists y) *y = \&x\),
and \(\&'(x) = x\) otherwise. \(*'\) is the dual of \(\&'\). Unlike the
familiar C operators, our pointer mutations therefore have algebraic
closure.</li>
<li>a permuation operation, by which two randomly selected machine words in a clump exchange
places;</li>
<li>a combination of 3 and 4, where two randomly selected words in a clump are chosen,
and one is replaced with their bitwise sum, the other with their bitwise product;</li>

</ol>

<p>
What the four mutation operations have in common is that
they share a certain minmal algebraic structure. Within each set, each
operation &#x2013; which, formally, is a endomorphism over \(\mathbf{[2^{32}]}\) &#x2013;
has an inverse: 
\[
(\forall M\in S)(\forall x)(\exists y) M(x) = y \Rightarrow 
(\exists M'\in S) M'(y) = x
\]
and an identity:
\[
(\forall M\in S)(\exists x) M(x) = x
\]
What this means is that over each set of mutation operators &#x2013; and
therefore over their union &#x2013; the concatenation or succession their
application forms a cyclic group.<sup><a id="fnr.14" class="footref" href="#fn.14">14</a></sup>
</p>

<p>
In practical terms, this is a generally beneficial property for genetic
operators to possess: all else being equal, they should be designed with
an eye towards neutrality with respect to an arbitrary choice of fitness
functions. By ensuring that the mutation operators are involutive, or, more
generally, that they form a cyclic concatenation group, involution just being
the smallest nontrivial form of such a structure, with a cycle of two, we
(imperfectly) guard against a situation where they ratchet the population into a
small corner of the genotypic (and, consequently, the phenotypic) landscape,
<i>independent of the fitness function</i>. (Identity is less significant, in this
context, and is introduced into the mutation operators only
as a way of ensuring closure.) Ratcheting occurs when the genetic
operators are not properly balanced. In the situation where the algebra defined
by concatenation over the mutation operators does <i>not</i> form a cyclic group &#x2013;
when there is &ldquo;no way back&rdquo; from some mutation \(M\) by any succession of further
mutations &#x2013; ratcheting is inevitable. This problem is distinct from, but
related to, the problem of genetic drift, which it exacerbates. Involutive pairs
of operators, selected with equal probability, provide some safeguard against
this. The <i>ideal</i>, in some sense, would be to select genetic operators that
would engender an <i>ergodic</i> system under a null fitness function:<sup><a id="fnr.15" class="footref" href="#fn.15">15</a></sup> one whose behaviour is evenly distributed
over the probability landscape it inhabits. In practice, even with fitness
anulled, evolutionary systems rarely exibit such regularity, which has some very
interesting effects on the paths that evolution pursues. We will study some of
these consequences in Chapter <a href="#/slide-org64aa169">5</a>.
</p>


</section>
<section id="slide-org86428c5">
<h4 id="org86428c5"><span class="section-number-4">4.3.2</span> Crossover</h4>
<p>
<a id="org14ac77f"></a> 
</p>

<p>
At a slightly higher structural level, the reproduction
algorithm may apply a crossover operation to the list of clumps, taking the
clumps as opaque units.
</p>

<p>
I chose single-point crossover over two-point or uniform crossover to favour
what I judged to be the most likely form for gene linkage to take in this
context: A single gadget can transform the cpu context in fairly complex
ways, since it may include any number of architectural instructions. The
prevalence of multipop returns in arm code further increase the odds that
the work performed by a gadget \(g\) will be clobbered by a subsequent gadget
\(g'\), and this risk increases monotonically as we move down the chain from \(g\).
This means that adjacent gadgets are more likely to achieve a combined,
fitness-relevant effect, than non-adjacent gadgets. Lacking any reason to
complicate things further, we restricted the number of parents involved in each
mating event to two. <sup><a id="fnr.16" class="footref" href="#fn.16">16</a></sup>
</p>


<p>
In single-point crossover between two genotypes, \(\mu\) and \(\varphi\), we
randomly select a link index \(\mu_i\) where \(\mu_i < |\mu|\), and \(\varphi_i\)
where \(\varphi_i < |\varphi|\). We then form one child whose first \(\mu_i\) genes
are taken from the beginning of \(\mu\), and whose remaining genes are taken from
the end of \(\varphi_{\mu_i\dots}\), and another child using the complementary
choice of genes. The only modification I make to this well-known algorithm, in
roper, is to weight the choices of \(\mu_i\) and \(\varphi_i\), using a
parameter we call &ldquo;fragility&rdquo;, whose calculation I explain in Section
<a href="#/slide-orgce7df1f">4.3.2.1</a>. The details of the algorithm itself can be found in
\ref{alg:crossover}.
</p>

<div>
\begin{algorithm}
\caption{Single-Point Crossover, with Fragility} \label{alg:crossover}
\begin{algorithmic}[1]

\REQUIRE $(\vec{\mu}, \vec{\varphi})$: ([\![ \textbf{clump} ]\!], [\![\textbf{clump} ]\!]), the parental genotypes 
\REQUIRE \emph{Fragility}: [\![\textbf{clump} ]\!] $\times$ [\![ \textbf{clump} ]\!] $\times$ lineage $\to \mathbb{F}$ 
\REQUIRE $(\mathfrak{R}, s)$: a PRNG and seed \REQUIRE $n$: $\mathbb{N}$, brood size


\STATE {$\mathfrak{R} \gets \textit{seed}(\mathfrak{R}, s)$} 
\STATE
{splice-points $\gets ()$} \COMMENT {the indices at which the parental genes
will be recombined} \FOR {$\vec{\alpha} \in (\vec{\mu }, \vec{\varphi})$} 
\STATE
{$t \gets \sum_{\alpha \in \vec{\alpha}} 1.0 - \textit{Fragilty}(\alpha)$}

\STATE {$p, \mathfrak{R} \gets \textit{random-float}(\mathfrak{R}, t)$} \COMMENT
{$p$ is more likely to fall on a highly fragile link} 
\STATE {$x \gets 0$}

\STATE {$i \gets 0$} \WHILE {$x < p$} 
\STATE {$x \gets x +
\textit{Fragility}(\alpha_i)$} 
\STATE {$i \gets i + 1$} \ENDWHILE 
\STATE {push
$(\vec{\alpha}, i)$ onto splice-points} \ENDFOR 
\STATE {\textbf{let} $\mu^a,
\mu^b = $ split $\mu$ at splice-points.lookup($\mu$)} 
\STATE {\textbf{let}
$\varphi^b, \varphi^a = \textit{split} \varphi \textit{at}
\textit{splice-points.lookup}(\varphi)$} 
\STATE {\textbf{let} $\chi^a = \mu^a
\cup \varphi^a$} 

\STATE {\textbf{let} $\chi^b = \varphi^b \cup \mu^b$} \RETURN
{$\chi^a, \chi^b$} \COMMENT {the offspring}
\end{algorithmic} 
\end{algorithm}

</div>

<p>
Crossover, so defined, has certain algebraic properties that allow it
to interact harmoniously with the forms of mutation specified in 
Section <a href="#/slide-org6a0db08">4.3.1</a>. If we abstract away from the information loss
enabled by the possibility of dropping of genes with low link fitness, a
probabilistic parameter that can be tuned, in roper, then, under the
assumption of a maximum genome length &#x2013; an assumption that holds in roper,
and which is imposed quite naturally by the practical limits of stack space in
the target process &#x2013; the crossover function, too, can be shown to form a cyclic group
under concatenation. Let \(a\) and \(b\) be two chains selected for crossover, and 
\(C(a,b)\) the set of <i>possible</i> offspring that may emerge from their mating. If
we restrict the splice index of the crossover to be nonzero, then \(a,b \not \in C(a,b)\).
But if we then take the set \(\mathbb{C}(C(a,b))\) of all possible offspring resulting
from an inbreeding of members of \(C(a,b)\), then we <i>do</i> find that both \(a\) and \(b\)
appear in this set. There is provable possibility for a chain, identified only by
its packed composition and without considering its genealogical metadata, to be its
own grandpa. 
</p>

<p>
Crossover is therefore associative, and since the crossover operation is symmetrically
defined &#x2013; one of the two offspring that are <i>actually</i> produced by a mating of \(a\) 
and \(b\) will begin with clumps from \(a\), the other with clumps from \(b\), with the other
parent providing the tail &#x2013; we can show that the mutation operators defined in
Section <a href="#/slide-org6a0db08">4.3.1</a> commute with and distribute over crossover, if we consider
them as functions that take probability distributions of offspring as their codomain. 
</p>

<p>
This is still some distance from rigorously establishing that \gls{roper}&rsquo;s populations
will, asymptotically, approximate an ergodic system &#x2013; a system where any states that
are reachable at the outset remain reachable, by an arbitrarily long but
finite path of genetic operations, from any point in that system&rsquo;s evolution &#x2013; but
it does at least establish the plausibility of ergodicity. In practice, however,
convergence and evolutionary deadends may remain commonplace, and it is only a very
slight reassurance to know that such states of affairs are not irreversible or 
eternal, in principle. 
</p>


</section>
<section id="slide-org3036af7">
<h5 id="org3036af7"><span class="section-number-5">4.3.2.1</span> Fragility and Gene Linkage</h5>
<p>
<a id="orgce7df1f"></a>
</p>

<p>
As a way to encourage the formation of complex &rsquo;building blocks&rsquo; &#x2013; sequences of
clumps that tend to improve fitness when occurring together in a chain &#x2013; we
weight the random choice of the crossover points \(\mu_i\) and \(\varphi_i\),
instead of letting them be simply uniform. With each each adjacent pair of nodes
is associated a &ldquo;fragility&rdquo; value, representing the likelihood of that
pair being split by a crossover operation. The fragility of each link in \(A\) is
derived from the running average of fitness scores exhibited by the sequence of
ancestors of \(\mu\) who shared the same linked pair. Links that have a genealogical
track record of appearing in relatively fit ancestors (i.e., ancestors with anumerically 
<i>low</i> fitness rank) will have a correspondingly low fragility score, while links
from weaker genealogical lines will have a respectively greater fragility.
</p>

<p>
Following a fitness evaluation of \(\mu\), the link-fitness of each clump \(f(\mu_i)\)
(implicitly, between each clump and its successor) is calculated on the basis of
the fitness of \(\mu\), \(F(\mu)\): \[ f(\mu_i) = F(\mu)\] if the prior link fitness
\(f'(\mu_i)\) of \(\mu_i\) is <code>None</code>, and \[ f(\mu_i) = \alpha F(A) + (1-\alpha)
 f'(\mu_i) \] otherwise. The prior link-fitness value \(f'(\mu_i)\) is inherited from
the parent from which the child receives the link in question. If the
child \(\mu\) receives its \(i^{th}\) clump from one parent and its \((i+1)^{th}\) clump
from another, or if \(i\) is the final clump in the chain, then \(f'(\mu_i)\) is
initialized to <code>None</code>.
</p>

<p>
Fragility is calculated from link-fitness simply by substituting a default value
(50%) for <code>None</code>, and taking the link-fitness score, otherwise.
</p>

<p>
In the event of a crash &#x2013; where the emulation of a specimen terminates
prematurely, due to a cpu exception, such as a segmentation fault or division by
zero &#x2013; the link-fitness of the clump prior to the one responsible for the
crash-event is severely worsened (raised) and the fragility adjusted
accordingly. Attribution of responsibility is approximate at best &#x2013; all we do
is lay the blame at the feet of the last clump to execute before the crash event
&#x2013; but the penalty is ultimately probabilistic. A clump whose successful
execution is highly dependent on the existing cpu context should be seen as a
liability, in any case, regardless of whether or not that same clump may have
behaved normally in other circumstances. (An example of such a clump would be
one that reads from a memory location specified by a register that it does not,
itself, set.) This penalty in link-fitness makes connections to the
crash-liable clump highly fragile, and so the weighted crossover employed here
becomes much more likely to set a splice point just prior to that clump.
This has the effect of weeding particularly hazardous genes out of the genepool
fairly quickly, as we will see.
</p>

</section>
<section id="slide-orgeae4a65">
<h3 id="orgeae4a65"><span class="section-number-3">4.4</span> Ontogenesis and Evaluation</h3>
<p>
<a id="org15035a0"></a>
</p>

<p>
The algorithms explained above all depend, either directly or in the way they
hang together, on having a way to evaluate the &ldquo;fitness&rdquo; of arbitrary genotypes.
</p>

<p>
The genetic programming literature often enlists the biological distinction
between <i>genotype</i> and <i>phenotype</i>.
</p>

</section>
<section id="slide-orgb38c5c5">
<h4 id="orgb38c5c5"><span class="section-number-4">4.4.1</span> From Genotype to Phenotype</h4>
<p>
<a id="orga653aa8"></a>
</p>

<p>
&ldquo;Genotype&rdquo; is used to refer to the immediate representations of the individuals
in the population, as sequences of semantically uninterpreted instructions. It
is, in a sense, a purely <i>syntactic</i> concept. The genotype is the genetic syntax
of an individual in the population, and belongs to the domain of the genetic
operators &#x2013; crossover, mutation, and so on, all of which operate on syntax alone,
at least in principle.<sup><a id="fnr.17" class="footref" href="#fn.17">17</a></sup>
</p>

<p>
<i>Selection</i>, however, does not directly operate on genotypes but <i>phenotypes</i>.
In the context of genetic programming, &ldquo;phenotype&rdquo; is the name given to the semantic
interpretation of an individual&rsquo;s genetic code. If the genotype is a sequence of
instructions, then the phenotype is the behaviour expressed when that sequence is
<i>executed</i>. Some theorists, such as Wolfgang Bahnzaf, have argued that the notion
of phenotype should be constrained further still, to refer not just to the semantic
interpretation of the genome, but to <i>the result of applying the fitness function
to that interpretation</i>. 
</p>

<p>
While this distinction does bring some clarity to the issue, and give the engineer
a better view of <i>what</i>, exactly, is the subject of selection, it does deprive us
of a nice term for the <i>intermediate representation</i>, between genotype and fitness
value. In roper, in particular, the semantic image of the genotype is complex
enough that it&rsquo;s worth distinguishing from its later collapse into a fitness value,
for some purposes. We have, moreover, set things up in such a way that it is possible
to vary the <i>fitness function</i> while keeping the semantic image &#x2013; what we call the
phenotype &#x2013; constant. It is simpler, in this case, to &ldquo;carve nature at the joints&rdquo;,
and define the fitness function as a function <i>from phenotypes to floats</i>, rather
than as much more complex function from genotypes to floats. The floats, in this
case, will be called &ldquo;fitness values&rdquo;, rather than phenotypes, as Bahnzaf would have it.
</p>

<p>
As for the function from genotypes to phenotypes &#x2013; the semantic evaluation function
&#x2013; we might as well keep on pilfering biology textbooks for our terminology, and
refer to it as <i>ontogenesis</i>.
</p>

</section>
<section id="slide-org40ac4e9">
<h4 id="org40ac4e9"><span class="section-number-4">4.4.2</span> Ontogenesis of a ROP-chain</h4>
<p>
Our definition of ontogenesis in roper should be no suprise: it is simply the
execution of the ROP-chain payload encoded in the genotype in the &ldquo;womb&rdquo; 
of the host process. 
</p>

<p>
If we strip away the clump structure, and associated metadata, such as fragility
ratings, with which we saddled our genotypes in order to provide better traction
to our genetic operators, what remains is just a stack of fixed-width integers.
Some of these integers index &ldquo;gadgets&rdquo; in the host process, while others are
there only to provide raw numeric material to register and memory operations. If
we take this stack, pack it down to an array of bytes, and write it to the stack
memory of the host process, we should be able to evaluate it simply by popping
the first item on the stack into the instruction pointer &#x2013; which is precisely
what would happen when a <code>pop {ip}</code> return instruction is executed.
</p>

<p>
From that point on, we only need to sit back at watch as the ensuing cascade of
returns executes our payload. This is no different from what takes place in
a ROP-chain attack in the wild &#x2013; aside from a few simplifications: for the time
being, we are abstracting away from any particular attack vector or preexisting
machine state. The registers of the virtual machine are all initialized to arbitrary,
constant values, and we don&rsquo;t bother to ask <i>how</i> the ROP payload happened to get
written to the stack. The stack is of fixed size, and restricted to the region
of memory that the ELF program headers precribe for it &#x2013; thereby placing an upper
bound on the effective size of individuals in our population &#x2013; but the exact
address of the stack pointer at the moment of inception is not based on any
observed process state, just set, conveniently, to the centre of the available
stack segment. No consideration, as of yet, has been given to avoiding &ldquo;bad
characters&rdquo; in our payloads, though introducing this restriction would be fairly
trivial. Execution is terminated as soon as any of the following conditions obtain:
</p>
<ol>
<li>the value of the instruction pointer is 0;</li>
<li>the cpu has thrown an exception (a segmentation fault, a bad instruction,
division by zero, etc.);</li>
<li>some fixed number \(n\) of instructions has been executed.</li>

</ol>

<p>
The first outcome is treated as a &ldquo;well-behaved&rdquo; termination, as though the
payload had reached its proper conclusion. Null bytes are written to the
stack just beneath each payload, with the intention of having <code>0x00000000</code>
popped into the instruction pointer by the final return statement. This condition, 
of course, can easily be gamed by an individual that finds another means of
zeroing out its instruction pointer, with something like
</p>
<pre class="example">
xor r3, r3, r3
mov ip, r3
</pre>
<p>
for example. 
</p>

<p>
The second and, to a lesser extent, the third outcome both result in a variable
penalty to fitness, the details of which will be discussed in Section <a href="#/slide-org9d05a99">4.4.3</a>.
</p>

<p>
The execution of the ROP chain payload is, in the context of roper, our
ontogenesis function: it gives us the phenotype, the behavioural, semantic
profile of the genotype. It is to this structure that the fitness functions
are applied. 
</p>

</section>
<section id="slide-org21fefee">
<h4 id="org21fefee"><span class="section-number-4">4.4.3</span> Fitness Functions</h4>
<p>
<a id="org9d05a99"></a>
</p>

<p>
Each of the fitness functions with which we&rsquo;ve experimented begin with a partial
sampling of the individual&rsquo;s behavioural profile, generally restricted to just
a few features:
</p>
<ol>
<li>the state of the \gls{cpu}&rsquo;s registers at the end of the individual&rsquo;s execution;</li>
<li>the number of gadgets executed, as determined by the number of <code>return</code>
instructions evaluated;</li>
<li>whether or not a cpu exception has been thrown.</li>

</ol>

<p>
This behavioural synopsis is then passed to a task-specific fitness function. We
experimented with three types of task : 
  a. reproduction of an specific register state, such as we might try to achieve
     in order to prepare the cpu for a specific system call, for example;
  b. classification of a simple data set, using supervised learning techniques;
  c. participation in an interactive game, where the evaluation of the payload
     makes up the body of the game&rsquo;s main loop.
</p>

<p>
The task-specific function maps the behavioural synopsis onto a double-width float,
between 1.0 and 0.0, with better performance corresponding to lower values. 
The exact nature of the tasks and performance of the system will be discussed in
detail in Chapter <a href="#/slide-org64aa169">5</a>. For the time being, the matter of cpu
exceptions deserves closer comment.
</p>

</section>
<section id="slide-org0dccd40">
<h5 id="org0dccd40"><span class="section-number-5">4.4.3.1</span> Failure modes and crash rates</h5>
<p>
Our population of random ROP-chains begins its life as an extraordinarily noisy
and error-prone species. The old problem of <i>computational brittleness</i>  resurfaces here in full force: the odds of a
randomly generated chain of gadgets executing without crashing is extremely
small  &#x2013; under 5%, on average, at the
beginning of a run.  If we were to let each crash count as unconditionally
lethal, this would impose such a tremendous selective pressure on the population
as to make it virtually unevolvable. What few islands of stability exist in the
initial population would be cut off form one another by an inhospitable ocean of
segfaults, leaving little room for exploration.
</p>

<p>
Fortunately, our chains have the luxury of being raised in the safety of a
virtual nursery, and nothing obliges us to make crashes unconditionally fatal.
We have at least two alternative possibilities:
</p>

<ol>
<li>apply a fixed penalty to fitness in the event of a crash,</li>
<li>make the crash penalty proportionate to the ratio of
the chain that executed prior to the exception, measured in gadgets</li>

</ol>

<p>
We decided to implement follow the second tactic, which we implemented by
trapping the return instructions in the Unicorn emulator. The lets us smooth an
abrupt cliff in the fitness landscape down to a gentle slope, incentivizing
adaptations that minimize the likelihood of crashing while at the same time
leaving room to reward specimens that do a failure good job of solving the
problems posed to them, even if they botch the landing. This prevents us from
sacrificing a number of useful genes, and gives them a chance to decouple from
their pathological counterparts, through crossover, or to be repaired through
mutation.
</p>

<p>
With this modification to the fitness function in place, the percentage of
chains that crash before completing execution has a tendency to drop to less
than 10% within a few hundred generations.  What&rsquo;s
particularly interesting is what happens when the average fitness of the
population hits a plateau: the crash rate begins to rise again, until the
plateau breaks, and the error rates begin to drop again. A plausible explanation
for this behaviour is that we are seeing the genetic search start to explore
riskier behaviours as the competition between combatants in each tournament
slackens (we will soon examine some examples in detail). As soon as a new
breakthrough is discovered in the problem space, the competition once again
hardens, and crash-prone behaviour becomes a more severe liability. In this way,
he fitness landscape, as a whole, becomes elastic.
</p>

</section>
<section id="slide-org05dc012">
<h4 id="org05dc012"><span class="section-number-4">4.4.4</span> Fitness Sharing</h4>
<p>
<a id="org20725f5"></a>
</p>

<p>
The most serious problem that \gls{roper}&rsquo;s populations appear to encounter, particularly
when dealing with relatively complex problem spaces &#x2013; classification problems or
interactive games &#x2013; is the depletion of diversity. 
</p>

<p>
As a population becomes increasingly homogenous, the exploratory potential of the
genetic operations becomes more and more constricted. There are two distinct, but
closely related, forms under which diversity should be considered here: genotypic
diversity and phenotypic diversity. At the beginning of the evolutionary process,
when the population consists entirely of randomly-initialized specimens,
genotypic diversity is likely at its historic peak: the sum of genetic
differences between each specimen and every other is maximal, with no
discernible &ldquo;family resemblance&rdquo; between them, beyond those afforded by chance.
Behavioural, or phenotypic, diversity, however, is typically rather meager at this
point. Unless the problem is extremely simple, and likely to be solved by random
search, the odds are that almost every specimen behaves in an effectively similar
fashion: near-total failure. Nevertheless, if sufficient genetic material exists, however, and if
the fitness function is sufficiently subtle, <i>some</i> phenotypic gradients will 
distinguish themselves from the white noise of failure, and it is these minor differences
that selection will accentuate. As a result, the population will often experience a
&ldquo;Cambrian Explosion&rdquo; of some form in the early phases of the evolutionary process: a
tremendous flowering of phenotypic diversity, paid for by a reduction in genotypic
diversity (at least insofar as we can measure genotypic diversity in terms of raw
hamming distances or bitstring similarity, without giving any consideration to structure).
The danger is that some particular family of phenotypes will be so strongly favoured
by selection that its corresponding genotypes <i>consistently</i> replicate faster than any
others, squeezing their rivals out of the population altogether. This can lead us to a
point where the exploratory power of recombination is nearly exhausted: the only remaining
sources of novelty, now, is the slow trickle of random mutation or the creation of new,
random individuals <i>ex nihilo</i>. The likelihood of this situation being disrupted by
sheer randomness, however, is as small as that of discovering competitive solutions to
the problem set through random search. The result is that evolution stagnates, if not
eternally, at least for much longer than we, as experimenters and engineers, would care
to wait.
</p>

<p>
When the problem set we are dealing with is plural &#x2013; as it is in the second and third types
of fitness function, listed in Section <a href="#/slide-org9d05a99">4.4.3</a> &#x2013; one way that diversity depletion often
occurs is through <i>hypertelia</i>, or an adaptive fixation on low-hanging fruit.<sup><a id="fnr.18" class="footref" href="#fn.18">18</a></sup> 
It is common for some subset of the problem set to be considerably simpler than the rest,
or for distinctions between certain classes in a classification problem to be more computationally
tractable than distinctions between other, more ambiguous or complexly defined classes. 
It is consequently likely that the population will produce specimens that are capable of
handling those simpler problems and clearer distinctions before anything exhibits comparable
skill in handling the &ldquo;harder&rdquo; problems. So long as the fitness function remains static,
selection will magnify this discrepancy, and the simple-problem-solvers will enjoy a persistent
reproductive advantage over any specimens that may be still fumbling their way through the
more complex regions of the fitness landscape. Once the bottomfeeders reach such numerical
dominance that they start to appear in the majority of tournaments, there remains very little
selective advantage in tackling any other aspect of the problem space, and the population
suffers a rapid loss of phenotypic diversity. Whatever tacit grasp on the problem
space&rsquo;s more challenging terrain may have emerged in the population up to that point is
quickly eclipsed and snuffed out. In the evolutionary computation literature, this dynamic
is referred to as &ldquo;premature convergence&rdquo;. 
</p>

<p>
What guards natural ecosystems against this development are the merciless
pressures of crowding, scarcity, competition, which introduce a dynamic selective
pressure for phenotypic diversity. The fitness rewards provided by low-hanging
fruit are no longer boundless, but diminish in proportion to the number of
individuals that reap them. At a certain point, the selective advantage no longer
lies with those individuals that exploit the same, simple regions of the problem
space, but with those who discover a niche that hasn&rsquo;t yet been picked thin by
crowds of competitors.
</p>

<p>
A similar tactic can be adopted in evolutionary computation, where it goes by
the name of &ldquo;fitness sharing&rdquo;. At least two implementations of this strategy
have become canonical in the literature: <i>explicit</i> fitness sharing, introduced
in <a href="~/org/bibliography.bib::deb89">~/org/bibliography.bib::deb89</a>, and <i>implicit</i> fitness sharing, introduced in <a class='org-ref-reference' href="#smith92">smith92</a>.
</p>

<p>
The underlying idea in both is that <i>selective advantage should be diluted by
nondiversity</i>. Explicit fitness sharing &ldquo;relies on a distance metric to cluster
population members,&rdquo; writes R.I. McKay in <a href="~/org/bibliography.bib::mckay00">~/org/bibliography.bib::mckay00</a>. &ldquo;Implicit fitness sharing,&rdquo;
by contrast, &ldquo;differs from the explicit form in that no explicit distance metric
is required. Instead, all population members which correctly predict a particular
input/output pair share the payoff for that pair.&rdquo; 
In roper we adopt a variation on the latter approach. The implementation is as
follows:
</p>

<ol>
<li>each exemplar is initialized with a baseline
<code>difficulty</code> score. It doesn&rsquo;t much matter which value is used for this,
but setting it to the inverse of the probability of solving the problem 
by random guess works well, when dealing with classification problems;</li>

<li>each problem is also allocated a <code>predifficulty</code> vector, which begins empty.
Every time an individual responds to the problem, its (its fitness assessment
for that particular problem) score is pushed into its <code>predifficulty</code> vector.</li>

<li>after a one &ldquo;season&rdquo; of tournaments has elapsed, where the length \(N\) 
of a season is defined as
\[N \gets \frac{\texttt{population\_size}}{\texttt{tournament\_size} * (1 - x)}\]
where \(x\) is the probability of &ldquo;headless chicken crossover&rdquo; (cf. Algorithm
\ref{alg:headless}), we iterate through the problem set. The
problem \(e\)&rsquo;s <code>difficulty</code> field is set to the mean of the predifficulty
vector. More difficult problems, at this point, are associated with a higher
difficulty score, which is always a float between 0.0 and 1.0.</li>

<li>once difficulty scores are available for each problem, the relative fitness of
each creature responding to it can be assessed: it is just the base, or &ldquo;absolute&rdquo;,
fitness score, multiplied by the inverse of the difficulty. If, for instance, 
\(X\) receives 0.75 on a problem for which the average performance has been
0.1, then \(X\)&rsquo;s relative fitness is \(0.75 * (1.0 - 0.1) = 0.75 * 0.90 = 0.675\).
If, on the other hand, it receives 0.2 on a problem for which the average performance
is a miserable 0.98, then its relative fitness comes to 0.004, reflecting the
rarity of its talents.</li>

</ol>

</section>
<section id="slide-org569c486">
<h5 id="org569c486"><span class="section-number-5">4.4.4.1</span> Mechanisms of Selection</h5>
<p>
This brings us back to where our algorithmic overview began: to the tournament
algorithm used to select mating pairs. In the interest of bolstering the diversity
of the population, and staving off premature convergence, we incorporated two
fairly well-known modifications into the steady-state, tournament selection
scheme described in Algorithm \ref{alg:evolve}: the partitioning of the population
into &ldquo;islands&rdquo; or &ldquo;demes&rdquo;, with rarefied points of contact, and the occasional use of 
&ldquo;headless chicken crossover&rdquo; as ongoing supply of novelty to the gene pool.
</p>

</section>
<section id="slide-orgc3dac68">
<h6 id="orgc3dac68"><span class="section-number-6">4.4.4.1.1</span> Islands in the Bitstream</h6>
<p>
The mechanism used to isolate \gls{roper}&rsquo;s subpopulation or &ldquo;demes&rdquo; is extremely simple:
when we go to select our candidates for each tournament, we do so by choosing 
\(n\) random indices \(\vec{i}\) into the general population array, but each time we
choose, we restrict ourselves to choosing integer between 0 and some constant, 
\(\text{island\_size}\), decided in advance. The index \(j\) of the candidate is then
set to \(j \gets i * \text{island\_size} + \text{island\_id}\). So long as this 
restriction is in place, each individual will only directly compete with its
compatriots, throttling the speed at which the population is likely to converge
on a single dominant genetic strain. This throttle is modulated by allowing the
selection of every \(m^{th}\) candidate to be chosen from the general population,
without any regard given to island of origin. The migration rate, \(m\), can be
easily adjusted to experiment with more and less genealogically interconnected
populations.
</p>

</section>
<section id="slide-org6490ce1">
<h6 id="org6490ce1"><span class="section-number-6">4.4.4.1.2</span> Headless Chicken Crossover</h6>
<p>
As a means of supplying the gene pool with an additional spring of novelty,
we also make use of a simple technique called &ldquo;headless chicken crossover&rdquo;,
which amounts to a small patch to Algorithm \ref{alg:evolve}: we replace
line \ref{alg:evolve:line:candidates} with Algorithm \ref{alg:headless}.
</p>

<div>
\begin{algorithm}
\caption{Headless Chicken Patch}
\label{alg:headless}
\begin{algorithmic}[1]
\REQUIRE {$H$: float, with $0.0 < H < 1.0$}
\REQUIRE {$\mathbf{G}, \mathbf{P}, \text{min}, \text{max}$: the parameters needed for
Algorithm \ref{alg:spawn}: the gadget pool, the integer pool, and the minimum and maximum
length of new individuals}
\STATE {$\frak{R}, i \gets \frak{R}$, {pick a random float} $0 < i < 1$}
\IF {$i < \textrm{headless\_chicken\_rate}$}
\STATE {$\frak{R}, \textrm{candidates} \gets$ using $\frak{R}$, pick $n-1$ from $\Pi$}
\STATE {$\frak{R}, \textrm{candidates} \gets \textrm{candidates} \cup \textit{spawn}(\frak{R},
\mathbf{G}, \mathbf{P}, \texttt{min}, \texttt{max})$}
\COMMENT {Using Algorithm \ref{alg:spawn}}
\ELSE
\STATE {$\frak{R}$, candidates $\gets$ using $\frak{R}$, pick $n$ from $\Pi$}
\COMMENT {As before}
\ENDIF
\end{algorithmic}
\end{algorithm}

</div>


</section>
<section id="slide-orgddf2b5f">
<h3 id="orgddf2b5f"><span class="section-number-3">4.5</span> Remarks on Implementation</h3>
<p>
The system described above has been implemented using the Rust programming
language, and the Unicorn emulation engine <a href="~/org/bibliography.bib::unicorn">~/org/bibliography.bib::unicorn</a> <a class='org-ref-reference' href="#nguyen15">nguyen15</a>. 
</p>

<p>
Rust was chosen for its speed, type-safety, and functional niceties, 
though this decision wasn&rsquo;t entirely unarbitrary &#x2013; prototypes of the
system in Lisp, Haskell, and OCaml are still strewn about my hard drives
and Git repositories in various states of incompleteness. The decision
to make use of the Unicorn framework remained somewhat more constant.
Evaluating arbitrary rop chains on bare metal turned out to be
every bit as hazardous and messy as it sounds, and so the need to find
a suitable virtualization framework became apparent very early in the
project. Spinning up full-fledged qemu vm for each evaluation
&#x2013; or even for each evaluation that ended in a fatal system state &#x2013;
would bring with it a prohibitive amount of overhead. I needed something
that would let me evaluate thousands upon thousands of individuals within
a reasonable timeframe. 
</p>

<p>
Unicorn, which its authors describe as, &ldquo;a lightweight multi-platform,
multi-architecture cpu emulator framework&rdquo;, exposes the cpu
emulation logic of qemu, while abstracting away from io devices and any
interface with the operating system, along with all their associated overhead.
The machine state of the emulator remains transparent, and is easily
instrumented by the user. This makes Unicorn ideal for performing a fine-grained
semantic evaluation of rop chains, under the assumption of a given cpu
context. The evaluation, that is to say, is strictly &ldquo;concrete&rdquo; &#x2013; it will tell
us only how a given chain will behave, <i>assuming that the cpu context and
memory space is in such and such a state</i>. This can be seen as an limitation of
roper, as compared to procedurally deterministic but symbolically
indeterministic rop compilers like <i>Q</i> <a href="~/org/bibliography.bib::schwartz11">~/org/bibliography.bib::schwartz11</a>, which makes use of symbolic
execution (via bap) to precisely determine the semantic valence of each
available gadget so as to <i>explicitly</i> fashion them into the isa targetted
by <i>Q</i>&rsquo;s own compiler. What \gls{roper}&rsquo;s procedurally stochastic and
semantically concrete (i.e. &ldquo;deterministic&rdquo;) approach loses in semantic
precision and robustness, however, is made up for with a singular cunning when
it comes to exploiting the <i>particular</i>, concrete state of its host process. Its
task, after all, is not to craft a portable, reusable rop payload that can
be cut-and-pasted, off-the-shelf into arbitrary attack contexts, but to craft
payloads that are as idiosyncratically adapted to the peculiarities of its
chosen target as a moth to its orchid.
</p>

</section>
<section id="slide-orge7f3e9d">
<h4 id="orge7f3e9d"><span class="section-number-4">4.5.1</span> Initialization of the environment</h4>
<p>
In the discussion of the algorithmic specification of roper, above,
we have, for the most part, abstracted away from the environment in which
the evolutionary process occurs. Setting up this environment is the first
task of the engine, and it proceeds as follows.
</p>

<p>
It begins by parsing and analysing the target binary &#x2013; either a standalone
executable, or a statically compiled library file. roper is currently 
only prepared to handle elf binaries targetting 32-bit, little-endian
arm architectures, though there&rsquo;s no <i>essential</i> reason for any of these
restrictions, and the system could be fairly easily adapted to handle other
abi formats (such as Apple&rsquo;s macho or Window&rsquo;s pe formats), or
other architectures (some tenative work on adapting roper to mips
is already underway, and it turns out to be fairly straightforward to 
take on other risc isa; cisc isa pose a few more
challenges, but tend to make for extremely fertile gadget sets &#x2013; the
x86 instruction set is so vast and intricate, for example, that
it can be a challenge to find a string of bytes that <i>can&rsquo;t</i> be parsed
as a series of x86 machine instructions!). 
</p>

<p>
roper reads the elf program headers and loads the program data into
the memory of a cluster of Unicorn emulator instances, at the appropriate
addresses, and with the appropriate permissions, just as the Linux kernel
would do when launching the executable on the metal. While doing this, 
roper (optionally) can ensure that w+x is enforced, even if not strictly
required by the binary.
</p>

<p>
Since roper, like any genetic programming system, relies heavily on
randomness, a word or two about its PRNG is in order. The prng
used is supplied by Rust&rsquo;s default <code>std::rand::thread_rng</code> function, which,
as of version 0.5 of the <code>rand</code> library, rests on an implementation of
the cryptographically secure hc-128 algorithm <a href="~/org/bibliography.bib::wu08">~/org/bibliography.bib::wu08</a>, seeded on a per-thread
basis by the operating system&rsquo;s entropy pool. In the current implementation,
the seeds passed to this generator are not logged, and cannot be manually specified
by the user, which makes the exact replication of a run impossible. I hope to
address this shortcoming in a future overhaul of the codebase. The salient point
about the prng, for now, is that it is of fairly high quality, and <i>should</i>
not be vulnerable to being exploited by the populations. 
</p>





<div>
\begin{savequote}
\textsc{Dr. Ian Malcolm} John, the kind of control you're attempting simply is... it's not possible. If there is one thing the history of evolution has taught us it's that life will not be contained. Life breaks free, it expands to new territories and crashes through barriers, painfully, maybe even dangerously, but, uh... well, there it is.

\textsc{John Hammond} [sardonically] There it is.

\textsc{Henry Wu} You're implying that a group composed entirely of female animals will... breed?

\textsc{Dr. Ian Malcolm} No. I'm, I'm simply saying that life, uh... finds a way. 
\qauthor{Michael Crichton, \emph{Jurassic Park}}
\end{savequote}

</div>

</section>
</section>
<section>
<section id="slide-orgf9467e5">
<h2 id="orgf9467e5"><span class="section-number-2">5</span> Experimental Studies</h2>
<p>
<a id="org64aa169"></a>
</p>


<div id="org490f358" class="figure">
<p><img src="../images/tomato-RT-N18U-httpd_heatmap.png" alt="tomato-RT-N18U-httpd_heatmap.png" />
</p>
<p><span class="figure-number">Figure 2: </span>Bitmap representation of the gadget distribution in the <code>tomato-RT-N18U-httpd</code> elf binary</p>
</div>

</section>
<section id="slide-orgc63e69a">
<h3 id="orgc63e69a"><span class="section-number-3">5.1</span> Overview</h3>
<p>
<a id="orgf02ffc1"></a>
</p>

<p>
As of the time of writing, I have experimented with four distinct classes of
fitness functions in roper, with a handful of variations within each class.
Though roper has been tested with numerous executable elf binaries,
compiled for the 32-bit arm architecture, for the sake of consistency, 
unless otherwise noted, all of the experiments discussed here make use of
a web server binary blob, pulled from the <code>tomato-RT-N18U</code> router firmware
image <a href="~/org/bibliography.bib::tomato-RT-N18U">~/org/bibliography.bib::tomato-RT-N18U</a>. The distribution of gadgets harvested from this
binary&rsquo;s <code>.text</code> section are plotted in figure <a href="#/slide-org490f358">2</a>, to which
I will make frequent reference in the subsequent heatmap overlay images.
</p>

<p>
In the following subsections (<a href="#/slide-org0b5ba28">5.1.1</a>, <a href="#/slide-org1926f89">5.1.2</a>,
<a href="#/slide-orgcff6734">5.1.3</a>, and <a href="#/slide-orgfde997f">5.1.4</a>), I will outline each task set that
roper was given to perform, and specify the way in which each was
incorporated into \gls{roper}&rsquo;s fitness function.
</p>

<p>
In Section <a href="#/slide-org34b7714">5.3</a>, I will walk through some of the more interesting results
gleaned from each experiment, and in Section <a href="#/slide-org2022006">5.4</a>, I will lay out certain
conjectures that address an enigma in the observed results, and set out another
series of experiments to test it. 
</p>

</section>
<section id="slide-org56d3d1c">
<h4 id="org56d3d1c"><span class="section-number-4">5.1.1</span> The null task</h4>
<p>
<a id="org0b5ba28"></a>
</p>

<p>
As discussed in Sections <a href="#/slide-org6a0db08">4.3.1</a> and <a href="#/slide-org14ac77f">4.3.2</a>, when designing a genetic
system, a question that naturally arises as to what constraints are brought into
play by the shape of the system itself, in its genotypic and phenotypic topography,
independent of any particular fitness function that could be applied to it. In the
case of simple and unilateral genetic algorithm systems &#x2013; where there is no distinction
between phenotype and genotype (the genetic syntax of individuals and their 
operational semantics), it is possible for the system to be strongly <i>ergodic</i>.
Under less harmonious conditions, however, there may exist various attractors in
the genotypic and phenotypic landscapes, and in their interaction, that incline
the system to converge in ways that are relatively independent of any specific
fitness function. 
</p>

<p>
One way to empirically study these dynamics is to define an
effectively uninformative fitness function, one that metes out rewards arbitrarily
and inscrutably, without any detectable pattern. A cryptographically secure
random number generator is well suited to this particular sort of absurdity, and
this is how roper implements its null task.<sup><a id="fnr.19" class="footref" href="#fn.19">19</a></sup> 
</p>

<p>
And since, in each of the other experiments, I enforce some form of crash penalty
as a component of the fitness function (see Section <a href="#/slide-org9d05a99">4.4.3</a> for details),
it would make sense to study what effects this pressure alone, abstracted from
the others, has on the population dynamics. For this reason, I will introduce
a second series of null task runs, in which the only non-random variable used
in reproductive selection will be the crash penalty. 
</p>

</section>
<section id="slide-orgcda4cba">
<h4 id="orgcda4cba"><span class="section-number-4">5.1.2</span> Preparing the parameters for a system call</h4>
<p>
<a id="org1926f89"></a>
</p>

<p>
This task is the most immediately practical of the set, and comes the closest to
a practical, &ldquo;real world&rdquo; application of roper in the domain of application
security. One of the most common use cases for a rop chain is to prepare
the cpu context for a particular system call, permitting the attacker to
read or write to a file, open a socket, execute a program, or any other task
that requires the cooperation of the operating system. To do this in assembly
or machine code, the programmer needs to set certain registers to contain and
point to the relevant values. To call <code>execv("/bin/sh", ["/bin/sh"], NULL)</code>, 
for instance, and spawn a shell process, on the arm architecture, she needs
to set register <code>R0</code> to point to the null-terminated string <code>"/bin/sh\0"</code>, 
register <code>R1</code> to point to a pointer to that string, set <code>R2</code> to zero, and
set <code>R7</code> to the code for this particular system call. Once this is done, dispatching
the call is just a matter of executing the <code>SVC</code> instruction. To perform this
operation with a rop chain, the same requirements must be met, but in a more
roundabout fashion, since the rop hacker isn&rsquo;t able to execute any instructions
directly, but must conduct the processor to execute a series of gadgets whose
cumulative effect is to prepare just this machine state. The final gadget in the
chain, however, is trivial: it is just the address of an <code>SVC</code> instruction, followed,
perhaps, by whatever series of gadgets is necessary to clean up the process and 
restore the normal flow of execution, if stealth is desired. (Though it&rsquo;s entirely
possible, in most cases, to simply let the host process crash after performing the
desired call &#x2013; it&rsquo;s just a bit sloppier, and can bring about other problems in the
context of a real-world attack.)
</p>

<p>
The task we assign roper is to carry out the preparation stage of this operation,
but it can easily be extended to complete the call &#x2013; it is, after all, just a matter
of appending a single, trivial gadget to the chain, which can almost always be found
in binary, since the <code>SVC</code> call is perfectly generic and does not embed any of its
arguments in the instruction itself. This step is omitted in our experiments only
because Unicorn abstracts away from any interaction with the operating system, and
doesn&rsquo;t handle system calls in a meaningful way. The cleanup stage is more context-sensitive
and complex, but something I may experiment with in the future, in order to prepare
fully deployable payloads with roper.
</p>

<p>
The fitness function defined for this task aims to be a gauge of the distance between
the register and memory state resulting from an individual chain&rsquo;s execution, and
the state required for the call. &ldquo;Distance&rdquo;, here, however, is a tricky concept, and
it isn&rsquo;t at all obvious how it should be defined in such as way as to both track
material progress towards the goal in view, and remain efficiently calculable. Ideally,
it would be defined as edit distance in the Markov chain that represents a genotype&rsquo;s
trajectory through probability space: how many generations, or applications of the
genetic operators, are required to achieve the target state, and how probable are each
of those genetic pathways? In practice, we make do with a very loose approximation of
this ideal:
</p>

<ul>
<li>For each target immediate value, we first check the execution result in the target register,
and take the hamming distance between the two values (the number of 1s in 
\(\text{target} \oplus \text{result}\)), and divide it by the maximum hamming distance
(32, on this architecture), storing the quotient in the variable <code>nearest</code>;</li>
<li>If \(\texttt{nearest} \neq 0\), we iterate through the remaining result registers,
and calculate the hamming quotient with the target for each value found there. We
then apply a &ldquo;wrong register&rdquo; penalty to the quotient, and if the result is still
less than <code>nearest</code>, we rebind <code>nearest</code> to the result.</li>
<li>We then pass to our memory samples from the execution &#x2013; one for each register that
could be validly referenced in the machine state at the end of execution, each holding
\(n\) bytes (currently, \(n\) is set to 512, but this may undergo tuning) from the
engine&rsquo;s memory, starting with the address in the register. We scan the memory
sample for the desired value, and, if found, we return the quotient of the value&rsquo;s
offset by the length of the sample (e.g., if we find it at offset 256, then we
return \(\frac{256}{512} = 0.5\)). If the index of the register dereferenced to
that memory sample is the same as the target&rsquo;s, then we consider this quotient
as a new candidate for <code>nearest</code>, after applying a &ldquo;right value, but needs to be
dereferenced&rdquo; penalty. If there is a mismatch in the register index, we also 
apply the &ldquo;wrong register&rdquo; penalty, and do the same.</li>
<li>After completing these iterations for a particular target register, 
we push the final setting of <code>nearest</code> into an error vector, to be considered later.</li>
<li><code>nearest</code> is then reset to the maximum value of \(1.0\), and we repeat the process for
the next immediate target register.</li>

<li>We then move on to the indirect targets in our target vector, and repeat more or
less the same process, first scanning the memory samples returned from the
individual&rsquo;s execution in the emulator, recording any findings, and then passing
on to consider the immediate values in the register, where we calculate the hamming
quotients, applying the same penalties as above wherever there occur mismatches 
between target and resultant register index, or mismatches between desired indirection
and resultant immediacy. At the end of each check, the final value of <code>nearest</code> is
pushed to the error vector.</li>
<li>Finally, we take the mean of the values in the error vector, and return it as a float
between \(0.0\) and \(1.0\): this is the fitness value for that particular evaluation.</li>

</ul>

<p>
The function used for the &ldquo;wrong register&rdquo; and &ldquo;needs to be dereferenced or indirected&rdquo;
penalties was, like most details in roper, arrived at through a great deal of
trial and error, and at the time of writing has settled into \(1 \sqcap \sqrt{x+0.1}\),
which seems to generate a reasonable amount of pressure while still maintaining
a traversable gradient in the fitness space. Restricting the primary distance measure
to hamming distance and forward linear scans feels like a fairly crude approximation,
but seem serviceable enough for now.
</p>



</section>
<section id="slide-orga7ac80c">
<h4 id="orga7ac80c"><span class="section-number-4">5.1.3</span> Classification problems</h4>
<p>
<a id="orgcff6734"></a>
</p>

<p>
\Gls{roper}&rsquo;s pattern-matching capabilities allow it to automate tasks commonly
undertaken by human hackers. The end result may not <i>resemble</i> a ROP-chain
assembled by human hands (or even by a deterministic compiler), but its function
is essentially the same as the ones carried out by most human-crafted
ROP-chains: to prepare the cpu context for this or that system call, so that
we can spawn a shell, open a socket, write to a file, dump a region of memory,
etc.
</p>

<p>
In this series of experiments, we&rsquo;ll see that roper is also capable of
evolving chains that are, in both form and function, entirely unlike anything
designed by a human. Though it is still in its early stages, and its
achievements so far should be framed only as proofs of concept, roper has
already shown that it can evolve chains that exhibit learned or adaptive
behaviour. To illustrate this, we will set roper the task of classifying, first,
a toy data set, designed for simplicity, and, second, Ronald Fisher and Edgar
Anderson&rsquo;s famous <i>Iris</i> data set.
</p>

<p>
The Iris data set is a well-worn benchmark for training elementary
machine learning systems,<sup><a id="fnr.20" class="footref" href="#fn.20">20</a></sup> and to the machine learning specialist, there is
nothing particularly interesting about yet another classifier churning out
results for such a relatively unchallenging set.
But, with these experiments, we enter essentially uncharted waters as far as
return-oriented programming &#x2013; or even, to the best of my knowledge, any form of
low-level &ldquo;weird machine&rdquo; exploitation &#x2013; is concerned. There is no real
precedent for having anything like a rop payload implement even a basic and
rudimentary machine learning benchmark, and so this task is introduced here
entirely as a proof of concept.<sup><a id="fnr.21" class="footref" href="#fn.21">21</a></sup> The interest, here, isn&rsquo;t in building a better mousetrap. It&rsquo;s in
showing that one can be built &#x2013; or bred &#x2013; out of utterly alien materials.
</p>


<p>
The Iris data set comprises series of four measurements &#x2013; sepal length,
sepal width, petal length, and petal width &#x2013;
for 50 specimens belonging to three different species of iris flower, 150
specimens in all. The task of the classifier is to predict the species when
given the measurements. &ldquo;One class is linearly separable from the other 2,&rdquo;
the documentation on the UCI Machine Learning Repository advises, &ldquo;the latter
are NOT linearly separable from each other.&rdquo; 
The fitness of each competing roper individual, in this context, will
depend on its ability to correctly classify the sample of specimens presented
to it. Since this is a balanced data set, detection rate alone is a sufficient
proxy for accuracy. The four attributes of each specimen will be cast and
normalized as integers, and, for each evaluation case, loaded into four of
the Unicorn \gls{cpu}&rsquo;s general purpose registers. The candidate chain is then
executed, as described above, and at the end of execution we read the values
contained in three distinct registers, designated as &ldquo;output registers&rdquo; for
this purpose. Each register represents a &ldquo;bid&rdquo; for one of the three possible
iris species. The values they contain are cast as signed integers, and the
register containing the largest value is interpreted as a winning bid for
its corresponding species. 
</p>

<p>
As we will see in a moment, experimentation has shown that an accurate and, if not
altogether efficient, at least timely<sup><a id="fnr.22" class="footref" href="#fn.22">22</a></sup> classification of the set can be achieved by
roper, so long as the fitness sharing mechanism discussed in <a href="#/slide-org20725f5">4.4.4</a>
is made available to it. 
</p>

<p>
The base fitness function used in the classification experiments is based on
register-bids: a subset of general purpose machine registers are designated
as &ldquo;output registers&rdquo;, and another, as &ldquo;input registers&rdquo;. At the beginning of
each evaluation case (each exemplar in the training set), the input registers
are loaded with values from the attribute fields. At the end of execution,
data is read from the output registers. Each output register is interpreted
as a signed integer, and taken to represent a bid on a class. The register
with the highest bid decides the individual&rsquo;s &ldquo;guess&rdquo; at which class the
attributes passed to it represent. In the event of a tie or an incorrect
guess, no points are awarded (the fitness value of this case is set to 1.0,
which is the poorest rating). In the event of a correct guess, 0.0 points
are awarded. That point value is then duplicated into a pair. The first
remains untouched, and is factored into the detection rate or &ldquo;absolute
fitness&rdquo; of the chain. The second is passed to subsequent modifications.
If the chain threw an exception during execution, for instance, then the
score is raised by a certain factor (which is tunable, and in some experiments,
dynamically variable in response to population trends), but it is constrained
to remain between 1.0 (worst fitness) and 0.0 (best fitness) at every point.
If fitness sharing is in effect, then the modifiable component of the score
has the inverse of the exemplar&rsquo;s difficulty added onto it. (If the chain
scored a 0.0 on an exemplar for which the mean performance is 0.85, for instance,
then it receives an additive boost of 0.15.)
</p>



</section>
<section id="slide-org85f110a">
<h4 id="org85f110a"><span class="section-number-4">5.1.4</span> &ldquo;Would you like to play a game?&rdquo;</h4>
<p>
<a id="orgfde997f"></a>
</p>

<p>
Naturally, the first question that comes up when you find a way of eliciting
rudimentary, intelligent behaviour from an exploited process is whether it
can play any games. This brings us to our fourth fitness function: we want
to train roper to evolve rop chains that can play a game of Snake.<sup><a id="fnr.23" class="footref" href="#fn.23">23</a></sup> For this purpose, I wrote a simple, machine-friendly implementation of the
classic arcade game in Lisp,<sup><a id="fnr.24" class="footref" href="#fn.24">24</a></sup> and set it up to communicate with roper over
a TCP connection. \Gls{roper}&rsquo;s task, here, is to evolve a rop chain that,
when run in a loop, can play a more or less competent game of Snake. The rop
chain is fed an array of first-person sensor readings, from the snake&rsquo;s perspective,
which indicate the relative distances of objects in the playing field: <i>apples</i>,
which increase the snake&rsquo;s length, <i>cacti</i>, which kill the snake on contact, 
segments of the snake&rsquo;s own body, which are similarly dangerous to collide with,
and the walls of the field, which, again, result in death on contact. 
Points are awarded to the player relative to the number of unique grid coordinates
visited, and the number of apples consumed, before dying. 
</p>




</section>
<section id="slide-orge08525e">
<h3 id="orge08525e"><span class="section-number-3">5.2</span> A few notes on terminology</h3>
<p>
<a id="orgf3add93"></a>
</p>

</section>
<section id="slide-org6db37f3">
<h4 id="org6db37f3"><span class="section-number-4">5.2.1</span> Iteration, generation, and season</h4>
<p>
<a id="org0bed842"></a>
</p>

<p>
roper employs a steady-state selection model in all of the experiments
discussed in this thesis, and so it&rsquo;s important to distinguish what we mean
by <i>generation</i> from what we mean by <i>iteration</i>. The notion of &ldquo;iteration&rdquo;,
here, is for the most part external to the actual evolutionary process &#x2013; it&rsquo;s 
an artefact of implementation, in a sense, representing only a cycle through
the &ldquo;main loop&rdquo; of the program, during which one or more tournements are thrown
in parallel. (I say &ldquo;artefact of implementation&rdquo; with a very large grain of
salt. If there are any fields of study that demand a healthy skepticism towards
what counts as essential to the specification, and what counts as &ldquo;mere
implementation details&rdquo;, they&rsquo;re computer security and evolutionary computation!)
An &ldquo;iteration&rdquo;, in this context, becomes a meaningful evolutionary unit
(modulo abstraction leaks) through a mediating notion that, in roper,
I&rsquo;ve called a &ldquo;season&rdquo;: a season is defined as a sequence of iterations that
is just long enough for it to become highly probable that more or less 
every member of the population has had their shot at a tournement (and, therefore,
a shot at reproduction). In concrete terms, the length of a &ldquo;season&rdquo; is a
function of tournement size and population size. 
</p>

</section>
<section id="slide-org08662bd">
<h4 id="org08662bd"><span class="section-number-4">5.2.2</span> Naming scheme for populations</h4>
<p>
<a id="org75056f1"></a>
</p>

<p>
Mentally keeping track of numerous, varying artificial populations is a challenge at the
best of times, and I&rsquo;ve found that assigning short,
pronounceable names to each batch is a useful mnemonic device. For this purpose,
I&rsquo;ve borrowed a trick from the designers of <i>Urbit</i>, and used strings of six
random letters, following the pattern &ldquo;<code>consonant vowel consonant consonant vowel consonant</code>&rdquo;<sup><a id="fnr.25" class="footref" href="#fn.25">25</a></sup>. Using these labels over the course of this chapter lets me avoid circumlocutions
like &ldquo;as seen in the second population discussed in Section $N&rdquo;, and has the
further advantage of setting up a self-documenting correspondence between the
analyses in this chapter and my system of log files. 
</p>


</section>
<section id="slide-org018d197">
<h3 id="org018d197"><span class="section-number-3">5.3</span> Initial Findings</h3>
<p>
<a id="org34b7714"></a>
</p>

</section>
<section id="slide-org8a3e375">
<h4 id="org8a3e375"><span class="section-number-4">5.3.1</span> Surveying the landscape with the null task</h4>
<p>
<a id="orge26e3ba"></a>
</p>

<p>
Before looking at the behaviour of roper under the influence of and constraints
of the semantically nontrivial fitness functions described above, let us first try
to get a sense of how the system behaves <i>without</i> receiving any meaningful fitness
information, and then move on to a constraint that is incorporated into each of the
fitness function considers, and acts as their common factor: the one imposed
by the crash penalty.
</p>

</section>
<section id="slide-orgb69f33a">
<h5 id="orgb69f33a"><span class="section-number-5">5.3.1.1</span> Arbitrary selection with no crash penalty</h5>
<p>
<a id="orgca4c042"></a>
</p>

<p>
<a href="../images/plots/kurlig_kafka_performance.pdf">../images/plots/kurlig_kafka_performance.pdf</a>
</p>

<p>
<a href="../images/plots/kurlig_heatmap_4_212_montage.pdf">../images/plots/kurlig_heatmap_4_212_montage.pdf</a>
</p>


<p>
The first thing that we wish to learn about how our populations behave under
randomized selection pressure is whether there are any discernible 
trends in the distribution of behaviours in those populations over time. 
One useful view on this distribution is the heatmap of addresses visited over the
course of the run, sampled seasonally. Though not a precise or statistically
significant representation of behaviour, it does, at least, serve to convey a
general impression, at let the eye pick out the more obvious skews in distribution. 
</p>

<p>
In figure <a href="#/slide-orgdce72b1">6</a>, we see heatmaps of the the <i>xeqcyv</i> population&rsquo;s
phenotypic distribution sampled at seasons 4 and 212. Qualitatively speaking, the
two maps appear almost identical. There has been no collapse of phenotypic diversity,
and the system even gives the impression of being ergodic. Acting freely, with
no systematic selective constraints, the mutation operators appear to be successfully
counteracting the pull of genetic drift. 
</p>


</section>
<section id="slide-org99d9463">
<h5 id="org99d9463"><span class="section-number-5">5.3.1.2</span> Arbitrary selection with crash penalty</h5>
<p>
<a id="org2101e57"></a>
</p>

<p>
<a href="../images/plots/xeqcyv_kafka_performance.pdf">../images/plots/xeqcyv_kafka_performance.pdf</a>
</p>


<p>
Surprisingly, even with the crash penalty in place, the distribution of execution
path frequency remained strikingly consistent, at least to a distant and qualitative
inspection. The heatmap snapshots of the population&rsquo;s execution habits at Season 4,
and again at Season 212, showed such little difference that I had to check carefully
to make sure that I had not placed them in the wrong order, in figure
<a href="#/slide-orgdce72b1">6</a>. 
</p>

<p>
<a href="../images/plots/xeqcyv_kafka_heatmap_beginning_end.pdf">../images/plots/xeqcyv_kafka_heatmap_beginning_end.pdf</a>
</p>


<p>
The tendency of these populations to shrink from execution, as shown in figure
<a href="#/slide-orgd032afb">5</a>, is not at all surprising. The longer they spend in
execution, the greater their risk of crashing. Since crashing the the one <i>sure</i>
way to draw selection&rsquo;s wrath, the population is highly disincentivized to spend
any longer than they have to in execution. There is simply nothing for an
individual under such selective pressures &#x2013; and only those &#x2013; to gain by
running code on the cpu. There is no &ldquo;task&rdquo; to be completed in this setup,
after all. Computation, for the creatures of <i>xeqcyv</i> and <i>kurlig</i>, it essentially
vestigal, and rapidly atrophies. And so execution times contracted to as little
as 4 instructions on average, with much less variation than seen in the
<i>kurlig</i> population.
</p>

</section>
<section id="slide-orgeb883ac">
<h4 id="orgeb883ac"><span class="section-number-4">5.3.2</span> Preparing an execv() system call in the Tomato web server</h4>
<p>
<a id="orgf4c505c"></a>
</p>

<p>
In the experiments discussed here, we targetted the http daemon extracted from
the firmware binary of a popular, open-sourced arm router, with the filename
<code>tomato-RT-N18U-httpd</code>, and focussed on preparing a call to <code>execv()</code>. This binary
has the fortunate (for us) property of not only containing a considerable number
of gadgets, but several hardcoded path strings as well. <code>#!/bin/sh</code> sits comfortably
at address <code>0x0001bc3e</code>, for example &#x2013; though it is terminated by a newline (<code>0x0a</code>),
and not by a null byte. Another interesting string that we can find there, residing
at address <code>0x0001f62f</code>, is <code>"/tmp/flashXXXXX"</code> &#x2013; just a few hundred bytes below an
apparent error message, reading <code>"Unable to start flash program"</code>. It appears that
the <code>XXXXXX</code> suffix is overwritten at runtime, at some point, yielding a valid path
to an executable, which, presumably, reflashes the router and restores factory
settings<sup><a id="fnr.26" class="footref" href="#fn.26">26</a></sup>. And, just as we&rsquo;d expect, the pathname, along with <code>/bin/sh</code>, resides in 
<i>writeable</i> memory. The resources for exploitation are numerous here, and the
situation is ripe for \gls{roper}&rsquo;s exploration.
</p>

<p>
To get our proof of concept underway, we&rsquo;ll set out cpu state pattern string,
which roper will parse and use to parameterize its fitness function, to
</p>
<pre class="example">
0001f62f,&amp;0001f62f,00000000,_,_,_,_,0000000b
</pre>
<p>
Each comma-separated cell in the string represents a register. The commas indicate
registers that we don&rsquo;t care about for the purpose of this task, and they will be
ignored by the fitness function. The ampersand is the indirection operator, as in C, 
and it tells roper that <code>R1</code> should contain a <i>pointer</i> to the address of the
string, &ldquo;/tmp/flashXXXX&rdquo;, which, for its part, is known to reside at <code>0x1f62f</code>. 
</p>

<p>
A satisfactory cpu pattern was soon produced by an individual in the <i>wiwzuh</i> 
population, seventeen genealogical steps from the initial population. This specimen
isn&rsquo;t particularly complex, once you factor out a few of the detours it takes. The
It essentially works by just popping the necessary values from the stack to the
registers &#x2013; all evolution needed to do here was to find the values that 
hadn&rsquo;t been provided in the initial integer pool (such as the pointer\texttt{ 0xfff8} to the
value \texttt{0x1f62f}) and to place them in the necessary order. All that&rsquo;s needed in order
to actually launch this syscall is to place a single <code>SVC</code> instruction pointer
at the end of the packed chain shown in table \label{fig:wiwzuh}. The Tomato binary
has 859 to choose from, and the choice is more or less arbitrary. 
</p>

<p>
Even with so simple a task, the fitness landscape traversed by roper displays
a surprising degree of ruggedness, as we can see in figure <a href="#/slide-orgd5fe571">7</a>. 
</p>

<p>
<a href="../images/plots/wiwzuh_syscall_gaussian_3.pdf">../images/plots/wiwzuh_syscall_gaussian_3.pdf</a>
</p>

<p>
\needspace{32}
</p>

<div>
\begin{table}
\label{fig:wiwzuh}
\begin{lstlisting}
(*\textbf{Clumps:}*)
[*] 0000b4ac   00000000   00000b17   0000000b   0000000b   00000000  
[*] 0000d1a0   0001f62f   0001f62f   0001f62f  
[*] 00016654   706d742f  
[*] 0001706c   0001f62f   0000fff8   0001f62f  

(*\textbf{Packed:}*)
ac b4 00 00  00 00 00 00  17 0b 00 00  0b 00 00 00  
0b 00 00 00  00 00 00 00  a0 d1 00 00  2f f6 01 00  
2f f6 01 00  2f f6 01 00  54 66 01 00  2f 74 6d 70  
6c 70 01 00  2f f6 01 00  f8 ff 00 00  2f f6 01 00  

(*\textbf{Execution Trace:}*)
0000b4ac        pop {r4, r5, r6, r7, r8, pc}

0000d1a0        cmp r0, #0
0000d1a4        popeq {r3, r4, r5, pc}

00016654        cmp r0, #0
00016658        ldr r3, [pc, #4]
0001665c        moveq r0, r3
00016660        pop {r3, pc}

0001706c        ldm sp, {r0, r1}
00017070        add sp, sp, #0x10
00017074        pop {r4, r5, r6, pc}

(*\textbf{Registers:}*)
R0:  1f62f->706d742f  R8:  0->68732e00 
R1:  fff8->1f62f      R9:  0->68732e00
R2:  0->68732e00      R10: 0->68732e00
R3:  706d742f         R11: 0->68732e00
R4:  0->68732e00      FP:  0->68732e00
R5:  0->68732e00      SP:  2b053->0   
R6:  0->68732e00      LR:  0->68732e00
R7:  b->746e692e      PC:  0->68732e00
\end{lstlisting}
\caption{A perfected \texttt{execv()} payload on \texttt{tomato-RT-N18U-httpd}, from the \emph{wiwzuh} population, generation 17.}
\end{table}

</div>

<p>
<a id="orgd93c19f"></a>
I must make a correction to a report stemming from this series of 
experiments that I had previously published and presented (<a href="~/org/bibliography.bib::fraser17_gecco">~/org/bibliography.bib::fraser17_gecco</a>, 
<a href="~/org/bibliography.bib::fraser17_atlseccon">~/org/bibliography.bib::fraser17_atlseccon</a>). I had initially set the target pattern for these attacks
to <code>02bc3e,02bc3e,0,_,_,_,_,0b</code>, where I had identified <code>02bc3e</code> as the address
of the string <code>"/bin/sh"</code> in the httpd binary. This was inaccurate on three counts:
first, the address was off by\texttt{ 0x10000} bytes, as a more careful inspection of the
program headers &#x2013; and subsequent improvement of \gls{roper}&rsquo;s elf loader &#x2013;
revealed. Second, that string is not null-terminated, and so we&rsquo;d have trouble
passing it as-is to <code>execv()</code> &#x2013; though it is newline-terminated, sitting at
the beginning of an embedded shell script, and residing in writeable memory, so 
it&rsquo;s still likely of some use, with a bit of manoeuvering. Most seriously, though,
was a rookie mistake I had made in relaying <code>execv()</code>&rsquo;s signature: the second
parameter requires another degree of indirection, and so this particular payload
would have immediately resulting in a segmentation fault, if deployed in a real
scenario. These errors all stand corrected in the current document, and \gls{roper}&rsquo;s
handling of pointer indirection and dereference has been vastly improved, along
with its elf loader.
</p>


<p>
Some good nevertheless came from that oversight, as it called to my attention an
extraordinarily interesting and counterintuitive pattern in the behaviour of
many of \gls{roper}&rsquo;s strongest specimens, which was thrown in sharp relief by
the champion chain of that particular run, system call bugs notwithstanding.
The specimen that caught my interest is reproduced here, in table
\ref{tab:labyrinthine}.
</p>


</section>
<section id="slide-org4b240af">
<h4 id="org4b240af"><span class="section-number-4">5.3.3</span> Results of the classification problem</h4>
<p>
<a id="org88eaa6e"></a>
</p>

<p>
In what follows I describe some of the findings arrived at by experimenting
with assigning classification tasks to roper. Two different datasets are
considered: an artificially simple and linearly separable dataset consisting
of two classes, and the well-known &ldquo;iris dataset&rdquo; by Fisher. But first, a few
remarks on the character of the problems we&rsquo;re looking at seem worth making. 
</p>


</section>
<section id="slide-orgb10b329">
<h5 id="orgb10b329"><span class="section-number-5">5.3.3.1</span> Particular challenges imposed by ROPER&rsquo;s phenotypic landscape</h5>
<p>
<a id="org2660217"></a>
</p>

<p>
Studying \gls{roper}&rsquo;s handling of simple classification problems, where the
odds of success by any standard classification algorithm can be more or less
anticipated, throws into relief certain challenges that are peculiar to roper,
owing to the unusual terrain of the phenotypic landscape that it is forced to
traverse. The routes that it tends to carve out between problem and solution
are often extremely indirect and circuitous, due to pressures that are external
to the shape of the problem space, as specified in the data set, for example, but
internal to \gls{roper}&rsquo;s operational semantics.
</p>

<p>
To begin with, of course, there is the constant threat of segfaulting, which is
never a concern for genetic programming systems that have been designed, from the
ground up, with their intended purpose in mind (assuming there are no bugs in the
implementation). roper must not only find a solution to each problem in the
problem set, but do so without throwing the cpu into an exceptional state. At
the beginning of a run, <i>most</i> execution paths lead to a crash, as may be expected
when executing randomly assembled rop chains, on which very little prior
sanitization has been performed. A great deal of roper's evolutionary time
appears to consist in winnowing useful components out of their unviable, crash-prone
encasings.<sup><a id="fnr.27" class="footref" href="#fn.27">27</a></sup> 
</p>


<p>
Furthermore, even without considering the probability skews caused by genetic drift,
there is an unevenness in the space of possible outcomes &#x2013; represented, for example,
by register states &#x2013; that is imposed by the materials that the host binary makes
available. Consider, for instance, the distribution in the frequency of register
usage shown in figure <a href="#/slide-org75da293">3</a>. If the output registers
used for the bid-based classification function are, say, <code>R0</code>, <code>R1</code>, and <code>R2</code>, then,
all else being equal, we can expect to see the class designated by <code>R0</code> receive 
more attention, until the population calibrates itself.<sup><a id="fnr.28" class="footref" href="#fn.28">28</a></sup>
</p>


<div id="org75da293" class="figure">
<p><img src="../images/plots/tomato-register-histogram.png" alt="tomato-register-histogram.png" />
</p>
<p><span class="figure-number">Figure 3: </span>Register use histogram for the <code>tomato-RT-N18U-httpd</code> arm elf binary, used in many of the experiments documented here. The general shape of this distribution is representative of all of the gcc compiled arm elf I have looked at. The height of each bar represents the frequency with which the register, indexed on the X-axis, appears in pop-type instructions, in returns, and in the source and destination of data manipulation instructions.</p>
</div>

<p>
At the present time, no explicit adjustment is made to the fitness functions
to account for this uneveness, though the <i>difficulty</i> mechanism and its use in
fitness sharing (see Section <a href="#/slide-org20725f5">4.4.4</a>) provides a means for the evolutionary
process to, eventually, gain some traction on it.
</p>

<p>
These qualities should be borne in mind when assessing \gls{roper}&rsquo;s performance
on the following classification tasks. Its performance is in no way impressive,
when compared to any standard classifier implementation, and these results are
not intended to showcase \gls{roper}&rsquo;s merits <i>as</i> a classifier. They&rsquo;re put
forward as a proof of concept, demonstrating, by construction, that anything as
strange and improbable as <i>training a population of rop chains to recognize
patterns in data</i> is possible.
</p>

</section>
<section id="slide-org380bbdf">
<h5 id="org380bbdf"><span class="section-number-5">5.3.3.2</span> Classification of a simple, linearly separable dataset</h5>
<p>
<a id="org29d00f2"></a>
</p>

<p>
As a way of establishing the minimal feasibility of performing classification
tasks with roper, I tested the system with an extremely simple, linearly
separable dataset that I had generated artificially, with just two attributes
and two classes (see figure <a href="#/slide-org3e28ba4">4</a>).
</p>

<p>
roper had very little difficulty with this problem set, and was able to
generate fairly good classifications of the data in the initial trials (figure 
<a href="#/slide-org4f0c36b">10</a>). Its best specimen clearly relied on a single
attribute in forming their classifications &#x2013; basing them, it appears, on the
sign of the \(x\) parameter &#x2013; but it seems likely that some fine-tuning of the
(currently very naive) fitness function should be able to encourage a subtler
approach. A fine-tuning of the fitness sharing parameters would perhaps be
sufficient to draw selective pressure&rsquo;s attention to the two blue points
misclassified as red.
</p>


<div id="org3e28ba4" class="figure">
<p><img src="../images/plots/2_simple_blobs.png" alt="2_simple_blobs.png" />
</p>
<p><span class="figure-number">Figure 4: </span>An extremely simple, artificial data set, with two linearly separable classes determined by two points.</p>
</div>

<p>
<a href="../images/plots/kathot_champion_18916_blobs_disas.pdf">../images/plots/kathot_champion_18916_blobs_disas.pdf</a>
</p>

<p>
<a href="../images/plots/kathot_fitness.pdf">../images/plots/kathot_fitness.pdf</a>
</p>

</section>
<section id="slide-orgdbb9e77">
<h6 id="orgdbb9e77"><span class="section-number-6">5.3.3.2.1</span> A case study of malignancy in the <i>fizwej</i> population</h6>
<p>
<a id="orgb2d8cda"></a>
</p>

<p>
Meanwhile, in the <i>fizwej</i> population, a genetic strain emerged that had found
a way to classify the simple dataset flawlessly &#x2013; or nearly so. Though it 
had achieved an error rate of 0.0, it terminated its execution, every time, 
with an instruction that caused the cpu to crash with a write access violation.
This specimen illustrates a difficulty encountered often in roper populations:
the offending instruction was part of the same gadget that did most of the work
in solving the classification problem, which can be reduced to the following sequence
of instructions, given some loose constraints on the constant popped into <code>R4</code>:
</p>
<div class="org-src-container">

<pre  class="src src-asm"><span style="color: #bc6ec5; font-weight: bold;">0000acf4</span>    <span style="color: #4f97d7; font-weight: bold;">lsr</span> r2, r4, #5            <span style="color: #2aa1ae; background-color: #292e34;">;; </span><span style="color: #2aa1ae; background-color: #292e34;">a    := r4 &lt;&lt; 5</span>
...
<span style="color: #bc6ec5; font-weight: bold;">0000acac</span>    <span style="color: #4f97d7; font-weight: bold;">add</span> r3, r3, r2, lsl #2    <span style="color: #2aa1ae; background-color: #292e34;">;; </span><span style="color: #2aa1ae; background-color: #292e34;">Blue := Blue + (a &lt;&lt; 2)</span>
<span style="color: #bc6ec5; font-weight: bold;">0000ad00</span>    <span style="color: #4f97d7; font-weight: bold;">and</span> r2, r4, #0x1f         <span style="color: #2aa1ae; background-color: #292e34;">;; </span><span style="color: #2aa1ae; background-color: #292e34;">Red  := r4 &amp; 0b11111</span>
</pre>
</div>

<p>
After solving the classification problem with these instructions, the phenotype
has no possibility of avoiding the next instruction in the gadget:
</p>
<div class="org-src-container">

<pre  class="src src-asm"><span style="color: #bc6ec5; font-weight: bold;">0000ad04</span>    <span style="color: #4f97d7; font-weight: bold;">stmib</span> r1, <span style="color: #4f97d7;">{</span>r4, sl<span style="color: #4f97d7;">}</span>
</pre>
</div>
<p>
This instruction increments the value in <code>R1</code>, dereferences it, and then attempts to write
the contents of <code>R4</code> and <code>R10</code> (i.e., the stack-limit register, <code>SL</code>) to that
address. In the memory space mapped for <code>tomato-RT-N18U-httpd</code>, however, the
only legally writeably region of memory is the space allocated to dynamic memory
(where the heap resides) and to the stack,
from addresses \texttt{0x28000} to \texttt{0x28fff} and from \texttt{0x29000} to \texttt{0x2cfff}, respectively.<sup><a id="fnr.29" class="footref" href="#fn.29">29</a></sup>
In the 7289 different specimens recorded
from the <i>fizwej</i> population, by the time of its 64<sup>th</sup> season, that had this
particular gene and that had activated it to achieve a perfect detection rate 
on &ldquo;two simple blobs&rdquo;, not a single one had managed to reliably dereference
<code>R1</code> to a writeable address at the time it dispatched that fatal instruction. 
To do so, indeed, they would have had to had changed their calculation strategy
entirely &#x2013; their entire <i>modus operandi</i> consisted in setting <code>R1</code> to a negative
value when the exemplar belonged to the <b>red</b> class, and to a positive value when
it belonged to the <b>blue</b>, leaving <code>R0</code> more or less constant. All of the writeable
addresses in the process space, however, fall within the positive range mentioned.
The crash rate of this population rapidly reached 100%, driving itself into an
evolutionary dead end. 
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Start Address</th>
<th scope="col" class="org-left">End Address</th>
<th scope="col" class="org-left">Protections</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">\texttt{ 0x00000000}</td>
<td class="org-left">\texttt{ 0x00000fff}</td>
<td class="org-left">READ</td>
</tr>

<tr>
<td class="org-left">\texttt{ 0x00008000}</td>
<td class="org-left">\texttt{ 0x00020fff}</td>
<td class="org-left">READ &vert; EXEC</td>
</tr>

<tr>
<td class="org-left">\texttt{ 0x00028000}</td>
<td class="org-left">\texttt{ 0x00028fff}</td>
<td class="org-left">READ &vert; WRITE</td>
</tr>

<tr>
<td class="org-left">\texttt{ 0x00029000}</td>
<td class="org-left">\texttt{ 0x0002cfff}</td>
<td class="org-left">READ &vert; WRITE</td>
</tr>
</tbody>
</table>


<p>
<a href="../images/plots/fizwej_perfect_crash.pdf">../images/plots/fizwej_perfect_crash.pdf</a>
</p>

<p>
<a href="../images/plots/fizwej-badgenes.pdf">../images/plots/fizwej-badgenes.pdf</a>
</p>

<p>
<a href="../images/plots/fizwej_S124_heatmap.pdf">../images/plots/fizwej_S124_heatmap.pdf</a>
</p>

<p>
The obstacle that we&rsquo;re encountering here is that, owing to the complex structure
of the virtual instruction set that roper is working with &#x2013; an instruction set
made up of gadgets rather than single machine instructions &#x2013; it is possible, perhaps
even common, for a dangerous phenotypic trait to secure its place in the population
when it is genetically united with an advantageous trait. Of course, this isn&rsquo;t just
a problem for roper, but for biological organisms as well &#x2013; we see something
similar, for example, in the relation between malaria resistance and sickle cell
anemia <a href="~/org/bibliography.bib::haldane49">~/org/bibliography.bib::haldane49</a>.
</p>

<p>
The question of whether or not a particular gadget is malignant is highly
context-sensitive &#x2013; since crashes are most often brought about through a
register dereference and a subsequent attempt to either read from, write to, or
execute data at an address for which the requisite permission has not been
granted &#x2013; and the pressures borne by selection are sometimes too coarse-grained
to answer it before a selective epidemic occurs. It may be interesting to
attempt to incorporate a more sophisticated semantic analysis routine to inspect
gadgets that trigger a crash, and to determine whether or not they should be
removed from the gene pool &#x2013; an idea we will take up further in the discussion
of future directions for this project, in Section <a href="#/slide-org0393a4c">6</a>. Incorporating
a gauge of genetic, or low-level phenotypic, diversity into the fitness function
&#x2013; scaling fitness by the relative frequency of either the individual&rsquo;s
machine-word composition, or its execution path through process memory &#x2013; may
also help mitigate the threat of malignant genetic convergence.
</p>

</section>
<section id="slide-org0c606d0">
<h6 id="org0c606d0"><span class="section-number-6">5.3.3.2.2</span> An early encounter with a segfault plague, due to an vulnerability in the crash handling mechanism</h6>
<p>
<a id="org5bd26f4"></a>
</p>


<div id="org954282d" class="figure">
<p><img src="../images/plague.png" alt="plague.png" />
</p>
<p><span class="figure-number">Figure 5: </span>A plague of segfaults: the cyan line indicates the crash rate, and the lower left index shows the average genealogical generation, and not the number of iterations, as used in later graphs. The raw data for this experiment has unfortunately been lost, leaving only this artifact as a historical curiosity.</p>
</div>

<p>
This wasn&rsquo;t the first time that I had seen a segfaulting strain rise to
dominance in one of \gls{roper}&rsquo;s populations. In one, particularly fascinating
and unusually pathological trial with the Iris classification problem (which we
will look at more closely in Section <a href="#/slide-orgd65de36">5.3.3.3</a>) , which I stumbled
across early in the experimentation, the crash rate skyrocketed, and the <i>entire
population</i> fell victim to a congenital plague of segfaults before its
20,000<sup>th</sup> tournament iteration (figure <a href="#/slide-org954282d">5</a>). Due to the data that
was collected at the time being insufficiently coarse-grained, I cannot say
whether dynamics similar to those described in Section <a href="#/slide-orgb2d8cda">5.3.3.2.1</a> played
a role in this occurrence. At least one of the factors leading up to it was
uncovered, however, by reviewing the mean &ldquo;ratio run&rdquo; metric of the population:
the population had discovered a means of exploiting the sloppy implementation of
the gadget-return counter, which was responsible for tracking how many gadgets
had executed before a crash occurred, that was then in effect. New to the
Unicorn library and the Rust language, and somewhat frustrated with the
complications involved in having a callback to the Unicorn engine soundly pass
data back to the Rust context from which the engine was dispatched, I&rsquo;d taken a
shortcut and built a counter in what I expected would be an unused region of the
emulator&rsquo;s memory space, and then used a straightforward API to read the counter
from memory after execution had terminated. At the time, I imagined that though
there was some chance the counter could <i>perhaps</i> get corrupted, I would be able
to treat that corruption as inconsequential noise. This was a mistake, and the
population wasted no time in exploiting it. A dominant genetic strain had
evolved to hijack the return counter, setting it to an artificially high value
before wantonly crashing. The apparent success of those chains in executing
numerous gadgets before crashing meant had reduced the crash penalty to near
zero, and since enough of this line had managed to perform fairly well on the
classification task &#x2013; achieving an 82% detection rate against Iris &#x2013; in
addition to exploiting the experimental framework, they soon wiped out every
single lineage that they ran up against.<sup><a id="fnr.30" class="footref" href="#fn.30">30</a></sup>
</p>

<p>
This was by no means the norm, however. The bug was fixed, and a secure conduit
for the return counter was implemented, avoiding any in-band communication that
could be hijacked by the population it was meant to assess. As an additional
safeguard, a second factor was incorporated into the crash-penalty gradation:
the penalty would steepen in proportion to the global frequency of crashes in
the population. 
</p>

<p>
This bolstered the tendency of the crash rate to oscillate, of course, though
the oscillations appear to occur to some degree with or without the global
crash frequency penalty. The global crash rate would generally settle into
a comfortable oscillation between 1 and 20 percent of the population crashing,
at any given time. 
</p>

<p>
A stricter penalty could easily reduce the crash rate to almost zero, but
this appeared to negatively impact long-term performance. The fitness landscape
inhabited by \gls{roper}&rsquo;s populations, it seems, is extremely jagged, and
too strict a penalty to crashing would prevent the population from crossing 
from one fitness peak to another. It made more sense to work with the tendency
for crash rates to oscillate than against it, and allow exploration of more
dangerous waters so long as it doesn&rsquo;t threaten to risk the long-term well-being
of the population as a whole. 
</p>

<p>
In view of the phenomena described in Section <a href="#/slide-orgb2d8cda">5.3.3.2.1</a>, however, this approach to regulating the crash rate may warrant revision. 
</p>

</section>
<section id="slide-org7973094">
<h6 id="org7973094"><span class="section-number-6">5.3.3.2.3</span> A proposed method for regulating malignant genes with a TTL field</h6>
<p>
<a id="orgdca5501"></a>
</p>

<p>
Another mechanism that we could use to mitigate this dynamic may be to add
a ttl field to our <code>clump</code> datatype. With each crossover or cloning event, 
the ttl would be decremented, and when it reaches zero, the clump would be
excised from the genome and replaced with a new, randomly generated one, perhaps
with an identical spd and immediate component. In the event of a crash, we
could examine the address visitation path tracked by the emulator to find the 
last clump entered before crashing. Once the guilty clump is found, its ttl
could be halfed (or some order of magnitude greater than the linear decrement
that occurs in crossover). We could then experiment with the results of different
tunings to the ttl field and its methods, and see if this might be a better
way of regulating the crash rate than the current approach, which simply factors
a crash penalty into the same, scalar fitness value that determines reproductive
odds. 
</p>


</section>
<section id="slide-org17c534a">
<h5 id="org17c534a"><span class="section-number-5">5.3.3.3</span> <i>Fleurs du malware</i>: Classification of the Iris data set</h5>
<p>
<a id="orgd65de36"></a>
</p>

<p>
The Iris dataset, though relatively simple by contemporary classifier standards, 
is considerably more complex than the &ldquo;two simple blobs&rdquo; dataset explored in
Section <a href="#/slide-org29d00f2">5.3.3.2</a>. Its attribute-class mapping is plotted
in figure <a href="#/slide-orgce99abf">16</a>
</p>

<p>
<a href="../images/plots/iris_plot.pdf">../images/plots/iris_plot.pdf</a>
</p>


</section>
<section id="slide-org5923a41">
<h6 id="org5923a41"><span class="section-number-6">5.3.3.3.1</span> Without fitness sharing</h6>
<p>
The fitness curve of our best specimens <i>without fitness-sharing</i> typically took
the form of long, shallow plateaus, against the backdrop of a population swaying,
it seemed, more in response to genetic drift than selective pressure.
</p>

<p>
An interesting phenomenon seemed to recur in several populations, however, following
a prolonged fitness plateau: long after it had been effectively quelled by selective
pressure, the rate at which individuals crash during execution would begin to rise
again, climbing, in fits and starts, from near zero to up to 40% of the population.
This is what we see happening in figure <a href="#/slide-org5124344">6</a>, for example,
which documents one of the early experiments performed with roper.
</p>


<div id="org5124344" class="figure">
<p><img src="../images/plots/good-nosharing.png" alt="good-nosharing.png" />
</p>
<p><span class="figure-number">Figure 6: </span>Resurgence of the crash rate during a fitness plateau, in an early run of the Iris classification task, before implementing fitness sharing. The X-axis in the left-hand pane tracks the average generation of individuals, while the X-axis on the right tracks iterations of the main loop. The relation between the two measures is linear, and so these panes can be more or less superimposed.</p>
</div>

<p>
One possible explanation for this strange behaviour is that a second-order selective
pressure encourage intron formation, of which the crash rate may be a symptom,
if the method for forming introns, favoured by this population, involved individuals
altering their own call stacks so as to escape dependency on certain segments of their
genomes &#x2013; a strategy that might be viable for one or two generations, but may result
in more fragile chains in in subsequent ones. I explore this possibility in more
depth in section <a href="#/slide-orgcccf570">5.4.2</a>.
</p>

<p>
Curiously, the peak in crash rate coincides with a dip in the average length of the
population, which appears contrary to the supposition that the population was undergoing
a strong pressure for intron formation at this point &#x2013; code bloat is almost certainly
the <i>simplest</i> means of forming introns. This may be an artefact of the fragility
mechanic detailed in Section <a href="#/slide-orgce7df1f">4.3.2.1</a>, however: a sufficiently fragile gene
has a strong likelihood of simply being dropped during crossover, and passed to neither
offspring, and when a crash occurs, the fragility of the last gadget to have been
executed is automatically maximised. We could, therefore, be seeing a <i>consequence</i>
of the rising crash rate in the corresponding drop in genome length &#x2013; this does, at
least, appear to me to be a likely hypothesis.
</p>

<p>
Another, non-exclusive possibility is that the fitness plateau we can see,
stretching across the second half of the history documented in figure
<a href="#/slide-org5124344">6</a> is a symptom of (premature) genetic convergence. 
Perhaps it converged on a fitness peak that was robust enough to survive
a certain number of reproductive cycles &#x2013; long enough for it to establish
dominance in the population, and drive out competing phylogenic strains, but 
which was surrounded on all sides by steep ravines. By the time we start to reach
mean generation 220 or so, descendents of that strain may be starting to reach
the edges of that fitness plateau, and <i>their</i> descendents begin dropping off the
edge, en masse. This seems incongruous with the mean fitness line continuing to
progress, but this is just the mean, and may be the effect of that strain completing
its ill-fated domination of the gene pool.<sup><a id="fnr.31" class="footref" href="#fn.31">31</a></sup>
</p>

</section>
<section id="slide-org141abf7">
<h6 id="org141abf7"><span class="section-number-6">5.3.3.3.2</span> With fitness sharing</h6>
<p>
<a id="orga913c77"></a>
</p>

<p>
 What would consistently seem to occur in the classification runs performed
 using a static fitness function, keyed to detection rate, was that the
 strains in the population would emerge that could reliably distinguish the
 linearly separable species of iris from the others, but whose competence
 would end there. This is, of course, not a trivial accomplishment in itself
 for a randomly generated rop chain, and so this strain would rapidly
 outperform its competitors in almost every tournament in which it was
 represented, soon dominating the gene pool, and bringing about a genetic
 convergence of the population, whose performance would then plateau. If there
 had been any resources in the population that <i>could</i> have made some headway
 on distinguishing the two less tractable, and more entangled, species, had
they had time to be tuned by genetic operators, those resources would likely
have been expunged by the gene pool in their carriers&rsquo; fierce competition with
the &ldquo;bottom feeders&rdquo; whose high absolute fitness scores represented only a
facility for solving relatively <i>easy</i> problems.
</p>

<p>
<a href="../images/plots/nosharing.pdf">../images/plots/nosharing.pdf</a>
</p>

<p>
For this reason, I introduced into roper the <i>fitness sharing</i> mechanism 
that I have outlined in Section <a href="#/slide-org20725f5">4.4.4</a>. 
 The result (after some persistence and plenty fine-tuning) was a superb run &#x2013;
achieving 96.6% detection rate (0.034 absolute fitness) on the Iris set in
27,724 tournaments, 216 seasons of difficulty rotation, and an average
phylogenic generation of 91.3. Figure <a href="#/slide-org7d060bc">19</a> shows the course the
evolution took, with the right-hand panel showing the responding environmental
pressures &#x2013; the <code>difficulty</code> scores associated with each class, showing both
mean and standard deviation.
</p>

<p>
<a href="../images/plots/sharing.pdf">../images/plots/sharing.pdf</a>
</p>



<p>
This run can be informatively compared with the one illustrated in figure
<a href="#/slide-orgc58e824">18</a>. Note the tight interbraiding of problem difficulties in
figure <a href="#/slide-org7d060bc">19</a>, as compared to their gaping &#x2013; but still, slowly,
fluctuating &#x2013; disparity in figure <a href="#/slide-orgc58e824">18</a>. The ballooning standard
deviation of difficulty by class in figure <a href="#/slide-org7d060bc">19</a> also suggests
a dramatic increase in behavioural diversity in the population, which is
precisely what we aim for with the fitness sharing algorithm.
</p>


</section>
<section id="slide-org8114b0c">
<h4 id="org8114b0c"><span class="section-number-4">5.3.4</span> Preliminary results of the <i>Snake</i> experiments</h4>
<p>
<a id="orgf2e8a69"></a>
</p>

<p>
In the final problem class put to roper, I wrote a simple <i>Snake</i> game
<a href="~/org/bibliography.bib::snakefight">~/org/bibliography.bib::snakefight</a> for its populations to play, to see how they may respond to a
dynamically changing environment, with moderate to high degrees of randomness.
The specifications of the game are described above, in Section <a href="#/slide-orgfde997f">5.1.4</a>.
To control the degree of randomness, I set up the game control protocol so that
the roper engine could pass a random seed to the game in order to initialize
the placement of &ldquo;apples&rdquo; and &ldquo;cacti&rdquo; on the game board. Surprisingly, the 
system appeared to perform better when the seeds were randomly generated and
highly unique, rather than drawn from small set of seeds that would remain fixed
for the duration of the evolutionary run. 
</p>

<p>
Results on this experiment remain largely preliminary and anecdotal in nature,
but evidence of its basic feasibility can be found in the time-lapse recording
of the final champion of the <i>misjax</i> population playing a semi-competent game
of Snake in figure <a href="#/slide-orgdd85e75">7</a>. 
</p>


<div id="orgdd85e75" class="figure">
<p><img src="../images/snek_misjax_montage_on_white.png" alt="snek_misjax_montage_on_white.png" />
</p>
<p><span class="figure-number">Figure 7: </span>Time-lapse rendering of one of the fitter specimens encountered in the Snake trials (<i>misjax</i> population). Snake segments: <code>[]</code>, apples: <code>()</code>, cacti: <code>##</code>.</p>
</div>



</section>
<section id="slide-orgf5199d3">
<h3 id="orgf5199d3"><span class="section-number-3">5.4</span> Intron Pressure, Self-Modifying Payloads, and Extended Gadgetry</h3>
<p>
<a id="org2022006"></a>
</p>

<p>
In all of the experimental trials performed, a certain number of peculiar,
interrelated phenomena appeared in the dynamic behaviour of the population
as a whole. 
</p>

</section>
<section id="slide-org6fcd910">
<h4 id="org6fcd910"><span class="section-number-4">5.4.1</span> Crash Rate Oscillations</h4>
<p>
The first has to do with the observed crash rates. In the beginning &#x2013; as is to
be expected, since our initial gadget harvest is deliberately roughly hewn
and approximate, with no attempt to formally verify the individual reliability
or usefulness of each gadget or combination thereof &#x2013; the vast majority of our
specimens (80 to 90 percent) would crash before completing execution. This would
most often be the result of a segmentation fault, or memory access violation error,
when the specimens would attempt to dereference and invalid pointer, or jump to an
address outside of an executably-mapped segment of memory. Since such violations
carry with them a fairly steep penalty to individual fitness, <i>and</i> increase the
likelihood that the genes responsible for exposing the individual to such hazards
are dropped from the gene pool, the rate of crashes would always drop fairly quickly
within the first few thousand tournament iterations. There is nothing unusual or
unexpected about this &#x2013; reducing the likelihood of crashing is the simplest way
for any of our individuals to ensure their survival and prospects of reproduction,
and appears to be much easier for our populations to accomplish than the specific
task-oriented components of the fitness function. And whereas the prospect of
crashing &ldquo;in the wild&rdquo;, before having a chance to reproduce, is completely and
utterly fatal to evolving malware strains (see the discussion of this problem
in Section <a href="#/slide-orgc451a80">3.1</a>), our &ldquo;in vitro&rdquo; populations have the advantage of a gently
gradated crash penalty: the fitness penalty incurred by a crash is inversely
proportionate to the number of gadgets viably executed before the crash.
</p>

<p>
What <i>is</i> surprising, however, is that the crash rate does not <i>continue</i>
to decline or stabilize at the extremely low level that it tends
to reach after its initial dropoff. The curve it traces relative to the
number of iterations doesn&rsquo;t even <i>approximate</i> a monotonic reduction.
Instead, it eventually &#x2013; but consistently &#x2013; begins to rise soon after the
average fitness of the population reaches a plateau, and then starts to
oscillate, until the plateau is broken and the fitness equilibrium is
punctured. 
</p>

</section>
<section id="slide-org8f15792">
<h4 id="org8f15792"><span class="section-number-4">5.4.2</span> The stray rate and extended phenotypes</h4>
<p>
<a id="orgcccf570"></a>
</p>

<p>
Once a secure conduit had been implemented for passing detailed execution
information from the emulator back to the evolutionary engine (see Section
<a href="#/slide-org5bd26f4">5.3.3.2.2</a>,
another rich vein of information had opened up, which helped to provide evidence for a
tendency that, until then, I had only been able to observe by manually
dissecting the disassembly dumps of individual specimens post-mortem<sup><a id="fnr.32" class="footref" href="#fn.32">32</a></sup>: I had noticed a tendency for roper populations&rsquo; best
performers to frequently be those that take strange and enigmatic risks with their own
control flow &#x2013; manipulating the program counter and stack pointer directly,
pushing values to their own call stack, branching wildly into unexplored regions
of memory space, and so on. These are behaviours that seem, <i>prima facie</i>, destined
for failure in most cases. Their apparent frequency was an enigma. 
</p>

<p>
Consider, for example, the specimen displayed in 
table \ref{tab:labyrinthine} which
achieved a perfect fitness in trial of the CPU context matching experiment,
where the task was to prepare the register vector for an
</p>
<pre class="example">
execv("/bin/sh", ["/bin/sh"], 0)
</pre>
<p>
system call &#x2013; the sort of task that manually crafted rop chains are often
designed for, so that the attacker can spawn a shell with the privileges of the
exploited process.<sup><a id="fnr.33" class="footref" href="#fn.33">33</a></sup>
</p>


<div>
\begin{table}
\label{tab:labyrinthine}
\begin{multicols}{2}
\begin{lstlisting}[basicstyle=\scriptsize\ttfamily]
;; Gadget 0 
000100fc         mov r0,r6 
00010100         ldrb r4,[r6],#1 
00010104         cmp r4,#0
00010108         bne #0xffffffb8 ;; = -0x48
0001010c         rsb r5,r5,r0 
00010110         cmp r5,#0x40
00010114         movgt r0,#0 
00010118         movle r0,#1 
0001011c         pop {r4,r5,r6,pc}

;; Gadget 1 
(*\color{violet}00012780~~~~~~~~~bne \#0x18*)
00012798         mvn r7,#0 
0001279c         mov r0,r7
000127a0         pop {r3,r4,r5,r6,r7,pc}

;; Gadget 2 
00016884         beq #0x1c 
00016888         ldr r0,[r4,#0x1c] 
(*\color{violet} 0001688c~~~~~~~~~bl \#0xfffffff0*) ;; = -0x10 
(*\color{red} 0001687c~~~~~~~~~push {r4,lr}*)
00016880         subs r4,r0,#0 
(*\color{violet}00016884~~~~~~~~~beq \#0x1c*)
000168a0         mov r0,r1 
000168a4         pop {r4,pc}

;; Extended Gadget 0 
00016890         str r0,[r4,#0x1c] 
00016894         mov r0,r4
00016898         pop {r4,lr} 
(*\color{violet}0001689c~~~~~~~~~b \#0xfffffdd8*) ;; = -0x228
(*\color{red}00016674~~~~~~~~~push {r4,lr}*)
00016678         mov r4,r0 
0001667c         ldr r0,[r0,#0x18] 
00016680         ldr r3,[r4,#0x1c]
00016684         cmp r0,#0 
00016688         ldrne r1,[r0,#0x20] 
0001668c         moveq r1,r0
00016690         cmp r3,#0 
00016694         ldrne r2,[r3,#0x20] 
00016698         moveq r2,r3
0001669c         rsb r2,r2,r1 
000166a0         cmn r2,#1 
(*\color{violet}000166a4~~~~~~~~~bge \#0x48*)
000166ec         cmp r2,#1 
000166f0         ble #0x44 
00016734         mov r2,#0 
00016738         cmp r0,r2 
0001673c         str r2,[r4,#0x20] 
(*\color{violet}00016740~~~~~~~~~beq \#0x10*)
00016750         cmp r3,#0 
(*\color{violet}00016754~~~~~~~~~beq \#0x14*)
00016758         ldr r3,[r3,#0x20] 
0001675c         ldr r2,[r4,#0x20] 
00016760         cmp r3,r2
00016764         strgt r3,[r4,#0x20] 
00016768         ldr r3,[r4,#0x20] 
0001676c         mov r0,r4
00016770         add r3,r3,#1 
00016774         str r3,[r4,#0x20] 
00016778         pop {r4,pc} 

;; Extended Gadget 1 
00012780         bne #0x18 
00012784         add r5,r5,r7 
00012788         rsb r4,r7,r4 
0001278c         cmp r4,#0 
00012790         bgt #0xffffffc8 ;; = -0x38
(*\color{violet}00012794~~~~~~~~~b \#8*)
0001279c         mov r0,r7 
000127a0         pop {r3,r4,r5,r6,r7,pc}

;; Extended Gadget 2 
(*\color{violet}000155ec~~~~~~~~~b \#0x1c*)
00015608         add sp,sp,#0x58 
0001560c         pop {r4,r5,r6,pc}

;; Extended Gadget 3 
(*00016918~~~~~~~~~mov r1,r5*) 
0001691c         mov r2,r6 
(*\color{violet}00016920~~~~~~~~~bl \#0xffffff88*) ;; = -0x78
000168a8         push {r4,r5,r6,r7,r8,lr} 
000168ac         subs r4,r0,#0 
000168b0         mov r5,r1 
000168b4         mov r6,r2 
(*\color{violet}000168b8~~~~~~~~~beq \#0x7c*)
000168bc         mov r0,r1 
(*\color{blue}000168c0~~~~~~~~~mov r1,r4*)
000168c4         blx r2
\end{lstlisting}
\end{multicols}
\caption{Execution trace of a chain that generates the register pattern required for a call to \texttt{execv("/bin/sh", ["/bin/sh"], NULL)} in \texttt{tomato-RT-N18U-httpd}, by modifying its own call stack and executing numerous "stray" or "extended" gadgets, in the \emph{poclux} population. Modifications to the gadget stack are in red, jumps are in violet, and completion of target \gls{cpu} pattern is in blue. Free branches are separated by blank lines. The final instruction jumps to the designated stop address, \texttt{0x00000000}.}
\end{table} 

</div>

<p>
It&rsquo;s an extaordinarily labyrinthine chain, by human standards, and there&rsquo;s
 little in its genotype to hint at the path it charts through phenospace. Only 3
 of its 32 gadgets execute as expected &#x2013; but the third starts writing to its own
 gadget stack by jumping backwards with a <code>bl</code> instruction, which loads the link
 register, and then pushing <code>lr</code> onto the stack, which it will later pop into the
 program counter (in the context of rop chains, <code>push</code> instructions tend to work
as a form of primitive polymorphism, since what counts as &ldquo;code&rdquo; for the rovm 
isn&rsquo;t &ldquo;whatever pc is pointing at&rdquo; but &ldquo;whatever sp is pointing at&rdquo;). From that point forward, we are off-script. The next four
 &rsquo;gadgets&rsquo; appear to have been discovered spontaneously, found in the
 environment, and not inherited as such from the gene pool.<sup><a id="fnr.34" class="footref" href="#fn.34">34</a></sup>
</p>

<p>
By tracking every address visited by every chain in
its movement through the host process, I was able to confirm my suspicion
that this bizarre behaviour is not at all uncommon in \gls{roper}&rsquo;s populations
&#x2013; nor is it only to be found in pathological, crash-prone specimens. 
</p>


<p>
<a href="../images/plots/hepfap.pdf">../images/plots/hepfap.pdf</a>
</p>

<p>
<a href="../images/plots/fimjek_heatmap_montage.pdf">../images/plots/fimjek_heatmap_montage.pdf</a>
</p>

</section>
<section id="slide-org306000f">
<h4 id="org306000f"><span class="section-number-4">5.4.3</span> A conjectural explanation of stray-rate fluctuations as a result of intron pressure</h4>
<p>
What pressures could possibly be driving the evolution of such strange
specimens? The canonical set of gadgets that the population inherits as its
primordial gene pool is noisy and brittle enough, but at least those gadgets are
selected for stability &#x2013; first, prior to each run, by our gadget harvesting
routines, which look for code fragments that are at least <i>likely</i> to preserve
control flow, and then, throughout the run, by fitness pressures that penalize
the loss of execution control (chains which crash before completion, or which do
not reach the designated termination address within a fixed number of steps),
and genetic operators that will tendentially drop unreliable gadgets from the
gene pool. And yet we find a tendency for the population to occasionally favour
gadgets that overwrite the individual&rsquo;s own code stack, and branch to uncharted
regions of executable memory that have no direct representation in the set of
gadgets making up the gene pool.
</p>

<p>
This type of behaviour appears to proliferate at a certain phase of the
evolutionary trajectory, which is no doubt significant: it has a tendency to be
favoured by periods during which the average fitness of the population more or
less plateaus, and its standard deviation narrows.
</p>


<p>
As Bahnzaf and others have shown <a href="~/org/bibliography.bib::nordin95">~/org/bibliography.bib::nordin95</a> <a href="~/org/bibliography.bib::banzhaf98">~/org/bibliography.bib::banzhaf98</a>, these are typically the conditions
under which we should expect to see signs of an accelerating accumulation of
<i>introns</i>, or non-coding genes, in the population. The reason for this, Bahnzaf
conjectures, is that as dramatic improvements in the performance of the
specimens, with respect to their explicit fitness function, become increasingly
difficult to attain, and as specimens more and more find themselves competing
against relative equals, the immediate selective pressures imposed by the
fitness function become less decisive in steering the course of the evolution.
The greatest differential threat to our specimens &#x2013; or, rather, to their
genetic lineages &#x2013; during such plateaus, is no longer the performance of their
immediate rivals, but the destructive potential of the genetic operators
themselves. There is very little, after all, to prevent crossover or even
mutation from mangling the genome beyond repair, and yielding dysfunctional
offspring. Unlike animals, plants, or any advanced life forms familiar to us
from nature, our creatures lack any sophisticated mechanism for ensuring the
homological transfer of genes in sexual reproduction. There is very little to
predispose crossover operations to preserve adaptive groupings of genes, or to
replace the genes of one parent with semantically similar genes from the other.
The only structural constraint that we have explicitly afforded to those
operations is a fairly lighthanded &ldquo;fragility&rdquo; mechanism, that, over time,
decreases the chance that crossover will break apart adjacent pairs of genes
that have historically (in terms of the individual&rsquo;s own genealogy) performed
well together. But this is a very mild constraint.
</p>

<p>
The gene lines best protected against such threats are those that are structured
in such a way that crossover is least likely to do damage, or to break apart
genes that are best kept together. A relatively simple way to achieve such
protection is to pad the genome with semantically meaningless, or &ldquo;non-coding&rdquo;,
sequences. So long as the probability that any gene sequence will be affected by
the action of a genetic operator is inversely proportionate to the length of the
genome, increasing the genome&rsquo;s length by adding otherwise ineffectual sequences
makes it less likely for those operators to mangle it in a semantically
meaningful &#x2013; and <i>a fortiori</i>, semantically maladaptive &#x2013; way.
</p>

<p>
Introns are therefore a valuable resource for the gene pool, and are favoured by
selection as soon as the threat posed by the genetic operators outweighs the
threat posed by immediate rivals. A particularly common form that introns may
take, and which we see in a variety of genetic programming systems, is a NOP
instruction, an instruction that does nothing, or some sequence of instructions
that semantically cancel one another out. In order to exploit that resource,
however, we need both a base language in which NOPs or NOP sequences are
relatively common, and latitude in the maximum length of the individuals, so
that introns can be freely padded onto the genome.
</p>

<p>
In the context of ROP chains, a NOP is just a gadget that returns without
performing any other operations. If we were dealing with gadgets defined over
the Intel instruction set, we could find these just by taking the address of
<code>RET</code> instructions. When it comes to arm, however, such gadgets are
significantly rarer. We rarely find a pop instruction that <i>only</i> pops into the
program counter, without tainting the other registers as well. For reasons of
efficiency, most compilers favour multipop instructions. Longer gadgets are even
less likely to execute without inducing side-effects. As we have already noted,
we simply do not have the luxury of a sleek, minimal, more or less orthogonal
instruction set, where each instruction performs a single, well-defined,
semantically atomic operation. Our instruction set will almost always be a noisy
assemblage of irregular odds and ends, in which the sort of introns we typically
encounter in genetic programming systems is rather uncommon.
</p>

<p>
Gadgets that overwrite or leap out of their own ROP stack, on the other hand,
are relatively easy to come by. Though they pose a tremendous risk to the gene
line, when it comes to first-order fitness, they offer access to an otherwise
scarce resource: they protect against damaging crossover operations, by
rendering the entire, unused sequence of gadgets that will be either overwritten
or avoided, an unbroken sequence of introns. Crossover and mutation can do
whatever they will to the lower regions of these aberrant genome without
inflicting any damage on adaptive clusters of genes.
</p>

<p>
It is uncertain that roper would be able to discover these labyrinthine
passageways through its host if the selection pressure against errors
were more severe. The breaking of a fitness plateau, in most of the populations
observed, was forecasted by a momentary peak in the crash rate. This often
appears hand-in-hand with a periodic increase in genome length, which chimes
with some of Banzhaf&rsquo;s findings regarding the relation between intron bloat
and punctuated equilibrium in evolutionary processes <a href="~/org/bibliography.bib::banzhaf98">~/org/bibliography.bib::banzhaf98</a>.
During such periods, length begins to increase as protective code bloat
and a preponderance of introns is selected for over dramatic improvements in
fitness, since it decreases the odds that valuable gene linkages will be
destroyed by crossover.<sup><a id="fnr.35" class="footref" href="#fn.35">35</a></sup>
</p>

<p>
We see this clearly enough in our champion ROP-chain displayed in
Table \ref{tab:labyrinthine}, where 29 of its 32 gadgets
do not contribute in any way to the chain&rsquo;s fitness &#x2013; though they do increase
the odds that its fitness-critical gene linkages will be passed on to its
offspring.
</p>

<p>
Branching to gadgets unlisted in the chain&rsquo;s own genome can be seen as a
dangerous and error-prone tactic to dramatically increase the proportion of
introns in the genome. Selection for such tactics would certainly explain the
tendency for the crash rate of the population to rise &#x2013; and to rise, typically,
a few generations before the population produces a new champion.
</p>

</section>
<section id="slide-orge6eeb9d">
<h4 id="orge6eeb9d"><span class="section-number-4">5.4.4</span> Testing the Extended Gadgetry Conjecture with Explicitly Defined Introns</h4>
<p>
The explanation given above for the strange behaviour observed seems to me to
be compelling enough on strictly theoretical grounds, but it still remains
to be seen if it can withstand experimental testing. If, as I have conjectured,
this behaviour appears because it represents a rich, even if risky, source of
introns, which our system has, in various ways, made a rare resource, then we
should expect to see it decrease in frequency as a consequence of introducing a
much safer supply of <b>explicit</b> introns into the gene pool.<sup><a id="fnr.36" class="footref" href="#fn.36">36</a></sup> All we need to do is
to define a type of <code>clump</code> that doesn&rsquo;t code for any gadgets or immediates
in the actual payload, but which can still be manipulated by the genetic
operators. The simplest way to do this is just to attach an <code>enabled</code>
flag with each clump, which can be set to either <code>true</code> or <code>false</code>. When
<code>false</code>, the clump is ignored by the serialization procedure that prepares
the payload, so that it&rsquo;s never sent to the emulation engine. We will also
add a new mutation operator, which is able to toggle the <code>enabled</code> flag during
reproduction. This lets the intron serve the additional, potentially useful
purpose of acting as a repository for genetic information. If the selective
pressure responsible for &ldquo;extended&rdquo; or &ldquo;stray&rdquo; gadgets is indeed derivative
of the well-known pressure to generate introns, then these edi should 
be able to undercut their market share.
</p>

<p>
Patience, and an adaptively disadvantaged experimental setup, was eventually
rewarded with a compelling corroboration of the intron conjecture regarding
the proliferation of stray gadgets. 
</p>

<p>
Eight populations of rop chains over the <code>tomato-RT-N18U-httpd</code> binary were
initialized with identical parameters, with the sole exception of the edi
rate: four (<i>xufmoc</i>, <i>simtyn</i>, <i>surjes</i>, and <i>mycwil</i>) began with an edi
rate of zero, with no further possibility of acquiring edi through
mutation. The other four (<i>megkek</i>, <i>huzqyp</i>, <i>rofted</i>, and <i>qatjaq</i>) were
initialized with an approximate 10% edi ratio, and a 5% per-clump edi
mutation rate &#x2013; meaning that in the event of a mutation, which occurs in 50% of
reproduction events, the other 50% being the result of single-point crossover,
each individual clump has a 5% chance of being toggled. In the event of
crossover, the <code>enabled</code> flag is simply inherited, along with its clump,
unaltered. This is a fairly aggressive mutation rate, giving us a probability of
\[ \frac{\sum_{n-1} \frac{1}{20} * (1 - \frac{1}{20})^n}{2} \] that at least one
clump in a chain of length \(n\) will be toggled on or off, in each reproduction
event.
</p>

<p>
The task component of the fitness function for these trials was to match a
precisely specified cpu context, similar to the register-matching task
discussed in Sections <a href="#/slide-org1926f89">5.1.2</a> and <a href="#/slide-orgf4c505c">5.3.2</a>, but
with one key difference, incorporating a recent update to the engine: the
population would be responsible for matching not just a series of immediate
register values, but correctly dereferencing pointers as well (but only up to
one degree of indirection). The exact
pattern in question, in \gls{roper}&rsquo;s (updated) syntax, is:
</p>
<pre class="example">
0002cb3e,&amp;0002cb3e,000000000,_,_,_,_,0000000b
</pre>
<p>
Corresponding to the preparation of the cpu for the system call,
<code>execv("/bin/sh", ["/bin/sh"], NULL)</code>, with <code>/bin/sh</code> at address
\texttt{0x2cb3e}. We will be disregarding the fitness results for these experiments,
however. The populations were deprived of mutation operators, with the exception
of an edi toggling mutation in the cases of <i>xufmoc</i>, <i>simtyn</i>, <i>surjes</i>, and
/mycwil. Their task evaluation function was also hobbled, so that it would feed
them very little information regarding the proximity of the registers to a correct match &#x2013; nothing but the bitwise hamming distance, for both immediate and indirect register
values. They were designed to either fail indefinitely, or evolve for an extremely
long period of time before converging, the better to study their long-term
dynamics. 
</p>

<p>
The results, presented in figures <a href="#/slide-org67236f2">23</a> and
<a href="#/slide-org447a367">24</a>, were found to corroborate the intron hypothesis,
though not as dramatically as anticipated. One of the four edi populations
still showed a visible history of stray address visitation, but only one, as
compared to the four edi free populations, all of which showed signs of
straying. Though fine-grained genealogical data is not available for these
populations, the relative continuity of the stray line in the <i>rofted</i> population, 
appearing in figure <a href="#/slide-org67236f2">23</a>, suggest that this <i>may</i> be the
result of a single bloodline, in contrast to the edi free <i>surjes</i> and 
<i>simtyn</i> populations, where the incidence of strays appears in fits and starts, 
suggesting multiple genealogical origins. It would be interesting to repeat this
experiment with larger populations, and the collection of genealogical data, 
as time (and memory space for exponentially accumulating data) allow. 
</p>

<p>
The trajectory of the genome length curve in each population group is consistent
with what we know about introns and genetic bloat (cf. <a class='org-ref-reference' href="#banzhaf98">banzhaf98</a>), and
it is to be expected that the populations lacking edi would supplement
their absence with an accumulation of &ldquo;spare&rdquo; genes. But what&rsquo;s surprising is
that those same populations appear to be executing the majority of their
tremendously large genomes &#x2013; and doing so with relatively infrequent crashes. 
The non-\gls{edi} populations have an anomalous member in this respect, too:
the <i>xufmoc</i> population exhibits a sharp downwards trajectory in its genome
length, following its 2000<sup>th</sup> season.  
</p>

<p>
A surprising result is the the non-\gls{edi} populations appear to have a higher
ratio of executed gadgets &#x2013; even though this ratio is calculated only with respect
to <i>enabled</i> gadgets, excluding edi. The difference on this measure is rather
subtle, however, and may be the effect of noise, or overrepresented and idiosyncratic
bloodlines. 
</p>


<p>
<a href="../images/plots/edi_stray_montage.pdf">../images/plots/edi_stray_montage.pdf</a>
</p>

<p>
<a href="../images/plots/noedi_stray_montage.pdf">../images/plots/noedi_stray_montage.pdf</a>
</p>

</section>
</section>
<section>
<section id="slide-orga7f5224">
<h2 id="orga7f5224"><span class="section-number-2">6</span> Conclusions and Future Work</h2>
<p>
<a id="org0393a4c"></a>
</p>

</section>
<section id="slide-org2e7e58a">
<h3 id="org2e7e58a"><span class="section-number-3">6.1</span> The devil in the details</h3>
<p>
roper has been explicitly designed as a &ldquo;proof of concept&rdquo;, and not
as a refinement on existing prior art. The experiments documented here,
that is to say, represent the first glimpse we have had of the possibility
of rop chain evolution. The application of an existing body of knowledge
and techniques &#x2013; here, genetic programming &#x2013; to an otherwise familiar
application domain, admittedly, seems to be something somewhat narrower than
a <i>conceptual</i> innovation. 
</p>

<p>
But, on the one hand, the devil&rsquo;s in the details, and this is why I chose to
spend the majority of Chapter <a href="#/slide-org64aa169">5</a> labouring over peculiarities
in individual cases and idiosyncracies in population trends, rather than focus
on accumulating quantitative performance metrics. What we find there, I think,
are challenges <i>specific</i> to the domain of evolving populations of programs on
such &ldquo;weird machines&rdquo; as the rovm. It is one thing to design a system that
is optimised and streamlined, from the ground up, for use in machine learning
or evolutionary computation, but it is something quite different to look for
ways to foster evolution in uneven assemblages of found materials. These are
assemblages that supervene on designed and documented machines, but which,
considered at the level of abstraction on which they operate, <i>no one</i> has
designed, or documented, strictly speaking. No one <i>builds</i> a rovm; they
emerge accidentally through leaks in the procedural machine model around which
most software is designed and with an eye to which it is implemented. They
are systems that are <i>discovered</i>, more than invented, even as they lie at
the heart of artificial and meticulously crafted systems. They form a sort
of junkyard wilderness at the heart of computational civilization. Their
exploration and study is the art of hackers, but this project began with the
intuition that something more might be learned of this strange terrain if
we approach it from the side of the wilderness, instead of from the side of
the explorer, and see how far we can get in coaxing unexpected structures 
and behaviours from it by applying just a bit of selective pressure, and
letting the system tell us about itself through the constraints it imposes 
on the resulting evolutionary process. 
</p>

<p>
And rop is far from unique or special in this regard. The entire cybernetic
universe of processes and protocols is replete with accidental and supervenient
&ldquo;weird machines&rdquo;, unintentionally Turing-complete byproducts of their intentionally
designed substrates. From programmable elf headers to javascript engine heap
allocators, the technological environment bristles with computational potential
that no one <i>intended</i> to extend to its various, vulnerable interfaces. I believe
that the type of research conducted here, on the evolution of rop chains, can
be fruitfully extended to these other strange domains, and many more.<sup><a id="fnr.37" class="footref" href="#fn.37">37</a></sup> Very little
is necessary, after all, to create an evolutionary system, and with a bit of care
and craftsmanship, I believe that we can learn a great deal about what strange
forms of computation can be bred in the crevices of our familiar, algorithmic
abstractions. 
</p>

<p>
Exploring some of this terrain using the techniques employed above, and
extending them, is the first article of on my agenda of &ldquo;future work&rdquo;,
after this project. Even within the framework of roper, however, there
are a number of interesting open problems and refinements to be explored,
and I will use the remainder of this chapter to document a few of the most
pressing.
</p>


</section>
<section id="slide-org90588ba">
<h3 id="org90588ba"><span class="section-number-3">6.2</span> Futher experiments and modifications suggested by above results</h3>
<p>
The reader will have noticed that Chapter <a href="#/slide-org64aa169">5</a> raised at least
as many questions as it answered, and that only a fraction of them were dealt
with directly in that chapter. 
</p>

</section>
<section id="slide-orgfafee84">
<h4 id="orgfafee84"><span class="section-number-4">6.2.1</span> Adding a ttl field to clumps to contain malignancy and promote novelty</h4>
<p>
This was touched on in Section <a href="#/slide-orgdca5501">5.3.3.2.3</a>, in response to an interesting case
of a malignant gene being aggressively promoted by selection, in virtue of the
beneficial trait with which its malignancy was indissociably bound. It&rsquo;s the
sort of problem to which evolution systems whose components are semantically
complex and multivalent are prone. Attempting to regulate it by tinkering with
the weight of a single, scalar fitness value involved tradeoffs whose merit was
difficult to anticipate in advance<sup><a id="fnr.38" class="footref" href="#fn.38">38</a></sup>, and so another approach, orthogonal to the fitness mechanism, might be worth
exploring. It&rsquo;s implementation seems fairly straightforward, and it will be one
of the first experiments I perform with the system when time allows. 
</p>

</section>
<section id="slide-org3d1c434">
<h4 id="org3d1c434"><span class="section-number-4">6.2.2</span> Collecting comprehensive genealogical data on the population during runtime</h4>
<p>
Frequently, in my analysis of various peculiar behaviours in \gls{roper}&rsquo;s
populations, in Chapter <a href="#/slide-org64aa169">5</a>, my enquiry was cut short by a simple
lack of data. It would be interesting to know, for example, <i>just how often</i> a
fit chain descends from a crashing ancestor &#x2013; information that could be used in
calibrating an optimal crashing penalty or ttl, for instance, and which would
be very interesting in its own right. There&rsquo;s nothing difficult in principle in
collecting such data, but doing so efficiently will be an interesting optimization
challenge. 
</p>

</section>
<section id="slide-orgb55b02c">
<h4 id="orgb55b02c"><span class="section-number-4">6.2.3</span> Refactoring and optimization</h4>
<p>
I have a tendency to take new and ambitious projects as an opportunity to learn
a new language, and in the case of roper, this was Rust. Unfortunately, this
means that the entire codebase is <i>rife</i> with rookie cruft, and drowning in 
technical debt. The system needs a complete rewrite, and one made with polymorphism,
extensibility, and optimization in mind. This will let future experiments be 
performed faster, and future modifications easier to make, as new ideas present
themselves. The current state of the system has left the code difficult to reason
about, and cumbersome to modify. It is very much a first draft, and a beginner&rsquo;s
project. It was a joy to write, but I think it has long since outgrown its current
form, and very much deserves an overhaul &#x2013; one that includes unit tests and
documentation, to boot. 
</p>

</section>
<section id="slide-org6ba9478">
<h4 id="org6ba9478"><span class="section-number-4">6.2.4</span> The Snake game, and other interactive problem spaces</h4>
<p>
The experiment touched on in <a href="#/slide-orgf2e8a69">5.3.4</a> remained largely tangential,
and it cries out for completion and more careful study. This, too, is on the agenda. 
</p>

</section>
<section id="slide-orgb4d562c">
<h4 id="orgb4d562c"><span class="section-number-4">6.2.5</span> Testing ROPER&rsquo;s payloads on fully realized systems</h4>
<p>
In the experiments discussed above, we never went beyond studying the behaviour
of \gls{roper}&rsquo;s populations <i>in vitro</i>, trapped in their reasonably complete, but
still somewhat simplified and abstract emulated environment. It would be interesting
to see whether roper can evolve specimens that can be used in a &ldquo;real world&rdquo;
scenario &#x2013; testing them, at the very least, against a full-fledged qemu instance
of a router, for example, with an actual rce vulnerability as their point of
entry. This would mean <i>much</i> slower evolutionary cycles, of course, but perhaps
a pipeline could be set up between the Unicorn &ldquo;nursery&rdquo; where the chains evolve 
until they reach a certain threshold of fitness, and a more fully realized vm
where their <i>in vivo</i> viability is put to the test. 
</p>


</section>
<section id="slide-orgbc5af31">
<h3 id="orgbc5af31"><span class="section-number-3">6.3</span> Broader strokes</h3>
<p>
On the back burner, at present, sits a side project where I had begun to rewrite
roper from scratch, before realizing that this was perhaps a bit too
ambitious, given the time constraints of the thesis. This overhaul was initiated
with an eye to what I took to be a handful of serious limitations in \gls{roper}&rsquo;s
design (some of which are, at the same time, items of interest peculiar to roper):
</p>


<ol>
<li>the programming interface that it exposes to the evolutionary
algorithm is brittle and uneven, and in no way optimized for evolvability;</li>

<li>the evolutionary process has little means of gaining traction
on the genotypes&rsquo; program semantics &#x2013; in themselves, the genotypes are
little more than vectors of integers, and there is no way of acquiring any
information of how those vectors will behave, except for executing them &#x2013;
and this is something at which each individual only ever gets a single
attempt;</li>

<li>the reproduction algorithms are fixed, and, as we have seen,
most frequently destructive. There is nothing inherent in crossover, or in
our mutation operations, that makes them well suited to the problem of
recombining ROP chains, or exploring the uneven, and largely uncharted,
semantic space that the execution of those chains represents. We may not
<i>know</i> a better algorithm, but perhaps we could at least let roper
explore other possibilities, itself, and expose the reproduction algorithms
themselves to evolutionary pressure.</li>

</ol>

</section>
<section id="slide-org27e5e8d">
<h4 id="org27e5e8d"><span class="section-number-4">6.3.1</span> &ldquo;ROPUSH&rdquo; or &ldquo;ROPER II&rdquo;</h4>
<p>
A design idea for the second iteration of roper was spurred by an
interesting suggestion made by Lee Spector, in a discussion of some of my
preliminary results and challenges at GECCO 2017 (where I presented <a href="~/org/bibliography.bib::fraser17_gecco">~/org/bibliography.bib::fraser17_gecco</a>). Spector suggested that the
opacity and brittleness that I was grappling with in &ldquo;roper I&rdquo; might become
more tractable if, instead of having the individuals of my population be more or
less direct representations of ROP-chain payloads, I instead evolved populations
of ROP-chain <i>builders</i> &#x2013; programs that would compose ROP-chains from the
available materials, but which may, themselves, have a very different structure.
</p>

<p>
The ontogenetic map from genotype to phenotype would then consist of two phases,
rather than just one:
</p>

<ol>
<li>a mapping from the builder&rsquo;s code to a constructed payload, implemented
by executing the builder,</li>

<li>the mapping we&rsquo;re already familiar with, from roper, which maps the
constructed payload (ROP chain) to the behaviour of the attack in the
emulated host.</li>

</ol>

<p>
The language in which the builders are defined could then be tailored to fit the
situation as well as possible &#x2013; pursuing a strategy similar to the one that
SPTH used in the design of Evolis and Evoris.
</p>

<p>
I decided to experiment with style of language that Spector had, himself,
introduced into genetic programming, and write a dialect of PUSH for this
purpose &#x2013; a statically typed, FORTH-like language that is designed with an eye
towards evolutionary methods rather than use by human programmers. Unhandled
exceptions, for instance, are effectively absent from the language, optimizing
it for mutational robustness rather than debugging and predictability.
</p>

<p>
At present, an initial implementation of a PUSH-style virtual machine, designed
for building rop chains, that would then run on the Unicorn emulator &#x2013; for
which I wrote a basic library of Common Lisp bindings &#x2013; sits, like I said, on
the back burner of the current roper git repository. It would be interesting
to see this through to completion, when time allows. 
</p>

</section>
<section id="slide-org42444d8">
<h4 id="org42444d8"><span class="section-number-4">6.3.2</span> A return to Q, through the Binary Analysis Platform</h4>
<p>
I&rsquo;ve also become increasingly interested, lately, with the domain of semantic
binary analysis, and have been giving some though to switching from Unicorn
to bap as my rop chain evaluation framework. Here, I would be following
in the footsteps of <i>Q</i> <a href="~/org/bibliography.bib::schartz11">~/org/bibliography.bib::schartz11</a>, one of the projects that had first
inspired me to work in this problem space. I&rsquo;m interested in seeing where a 
marriage between <i>Q</i>&rsquo;s semantic-analysis driven compiler of programs for the
rovm, and \gls{roper}&rsquo;s evolutionary approach could take things. Having a
richer source of precise, semantic information to nudge the evolutionary process
through local hill-climbing searches, and a meaningful type system for gadgets
that could be used in fostering homologous crossovers and saner mutations, could
be an extraordinarily rich vein to mine. If roper II ever sees the light of
day, it will probably try to move in this direction as well, using bap to
extract type information and mediate evolutionary synthesis with intelligent
semantic analysis, with a highly flexible and evolvable, type-aware ROPUSH
abstraction layer coordinating those activities. 
</p>


<p>
Until then, I will tend to my rop.
</p>
</section>
</section>
<section>
<section id="slide-orgbd0a40a">
<h2 id="orgbd0a40a"><span class="section-number-2">7</span> Appendix: Further Adjustments</h2>
<div class="outline-text-2" id="text-7">
</div>
</section>
<section id="slide-org9a6b049">
<h3 id="org9a6b049"><span class="section-number-3">7.1</span> Adjusting the classification task function for better environmental compatibility</h3>
<div class="outline-text-3" id="text-7-1">
</div>
</section>
<section id="slide-org21c32cc">
<h4 id="org21c32cc"><span class="section-number-4">7.1.1</span> Disadvantages of the bid-based algorithm in ROPER</h4>
<p>
As we can see in figure <a href="#/slide-org75da293">3</a>, the distribution of register use
in a fairly typical arm elf program is hardly even. This places a tremendous skew
on the relative likelihood of register use by an arbitrary individual in \gls{roper}&rsquo;s
populations. And since the entire set of registers is initialized to the same, constant
set of values for each one, the ability of an individual to use the distribution of weights
in each register as a discriminant for a task is hamstrung from the outset. We are already
cutting the execution environment against the grain when we try to configure our
fitness functions in this way.
</p>
</section>
<section id="slide-org8b17977">
<h4 id="org8b17977"><span class="section-number-4">7.1.2</span> Using R0 to decide</h4>
<p>
The arm abi <a href="~/org/bibliography.bib::arm_abi">~/org/bibliography.bib::arm_abi</a> already gives us some useful hints here, which we can try to adhere to, to
make our fitness functions more harmonious with their environment. Like the x86, the arm
abi designates a particular register for the purposes of carrying a return value:
</p>
<blockquote nil>
<p>
The manner in which a result is returned from a function is determined by the type of that
result [&#x2026;] A Fundamental Data Type that is smaller than 4 bytes is zero- or sign-extended
to a word and returned in r0.
</p>
</blockquote>
<p>
Though larger values can enlist other registers as vehicles &#x2013; &ldquo;a 128-bit containerized vector
is returned in r0-r3&rdquo;, for example &#x2013; the sole use of r0 is by far the most common case, which
explains why we see it being given so great a preference in figure <a href="#/slide-org75da293">3</a>. 
</p>

<p>
&ldquo;Cutting with the grain,&rdquo; here, would mean adjusting our fitness function so that it hews a bit
closer to the expected behaviour of procedures in its host. We can try, in particular, to base
an individual&rsquo;s classification decisions (for the purposes of a classification task &#x2013; this doesn&rsquo;t
impact the syscall preparation task at all) on the contents of <code>R0</code>, alone. 
</p>

<p>
There are several ways we might do this: we could assign different integer ranges to each
class, and then choose the class whose range in which the value in <code>R0</code> falls. Deciding on 
a fair choice of ranges is a nontrivial problem, however, and will largely depend on the
vicissitudes of the binary under attack. 
</p>

<p>
We could allocate bit mask ranges to each class, and then the class for which <code>make_mask(class) &amp; R0</code> 
has the most high bits. This remains close to the bid-based approach, but uses bit slices of a single
register to provide the &ldquo;ballot boxes&rdquo;, rather than separate registers. As before, we could refuse
to assign points in the event of a tie: <code>0xffffffff</code> and <code>0x00000000</code>, for example,
should not designate any particular class, but be seen as a failure to choose &#x2013; which helps us
filter out quite a bit of noise and trivial decisions.  
</p>

<p>
Some experimentation showed, however, that slicing the 32-bit range into equal, contiguous
masks still results in a fairly significant skew in the early results, before selection has
gone to work: the lower 8 bits, for example, are consistently favoured, as are the top 8, since
they are set whenever the value in <code>R0</code> represents a negative integer. 
</p>

<p>
To balance the playing field, and ensure a bit of variety between runs, I used a simple algorithm
to allocate non-colliding, randomized masks to each class in the configuration stage of each run
(it&rsquo;s a crude, trial-and-error based, expensive algorithm, but negligibly so,
since it only needs to be performed once per run), such that the masks each contain an equal number
of ones, and have a boolean sum that has \(n\) ones, where \(n = 32 \mod |\text{classes}|\).
</p>

<p>
This method tends to give a more or less equal probability, it seems, to the base likelihood
of each class being chose, at least within one order of magnitude &#x2013; which is
sufficient, since we can let the fitness sharing mechanism sort out the
remaining disparities.
</p>

<p>
Results so far have been encouraging. A solution to the trivial classification problem, involving
two linearly separable blobs, was solved within minutes with a perfect detection rate, and a
more algorithmically interesting solution than we saw when using the register-bid approach
(which, I believe, encourages relatively trivial solutions that do not generalize well at all, in
the context of roper, since the only way to properly weight the registers is often by simply
moving the attribute values back and forth between output registers, with minor tweaking &#x2013;
resources for subtly manipulating values in the mid-range registers are just too scarce a resource
in \gls{roper}&rsquo;s environment). See tables \ref{tab:xysxim-champ-red} and \ref{tab:xysxim-champ-blue},
for execution traces of the champion classifier, operating on exemplars of the red and blue classes,
respectively. What we see here is something we saw only rarely when using the register-bid algorithm,
and almost never in the champions produced by that algorithm &#x2013; even when we try to encourage it
by incorporating a per-case performance diversity metric into the fitness
function: a difference in control flow, where \gls{arm}&rsquo;s own conditional
operators are used to decide on the course of action, given readings from a
particular exemplar. The decision point in these specimens is the <code>popeq</code>
instruction at address <code>0x0000cdd4</code>, which pops the stack if and only if the
<code>zero</code> flag had been set by the previous flag-setting instruction (here, <code>subs
 r4, r0, #0</code>, at <code>0x0000cdd0</code>).
</p>

<div>
\begin{table}
\begin{lstlisting}
IN:  a3 fffffd6f
0000b4b4       | pop {r4, r5, r6, r7, r8, pc}
0000d9a8       | cmp r0, #0
0000d9ac       | moveq r0, r3
0000d9b0       | pop {r3, pc}
0001010c       | rsb r5, r5, r0
00010110       | cmp r5, #0x40
00010114       | movgt r0, #0
00010118       | movle r0, #1
0001011c       | pop {r4, r5, r6, pc}
0000cdd0       | subs r4, r0, #0
0000cdd4       | popeq {r4, r5, r6, pc}
0000cdd8 stray | ldr r1, [pc, #0x1c]
0000cddc stray | mov r2, r4
0000cde0 stray | mov r0, #0
0000cde4 stray | bl #0x59e0
000127c4 stray | push {r1, r2, r3}
000127c8 stray | push {r0, r1, r2, r4, r5, r6, r7, r8, lr}
000127cc stray | mov r6, r0
000127d0 stray | mov r5, #0x400
000127d4 stray | add r7, sp, #0x28
000127d8 stray | ldr r8, [sp, #0x24]
000127dc stray | mov r0, r5
000127e0 stray | bl #4294933396
0000a374 stray | add ip, pc, #0
0000a378 stray | add ip, ip, #0x1e000
0000a37c stray | ldr pc, [ip, #0x5a8]!
0000a138 stray | str lr, [sp, #-4]!
0000a13c stray | ldr lr, [pc, #4]
0000a140 stray | add lr, pc, lr
0000a144 stray | ldr pc, [lr, #8]!
OUT: 400->0 1bc01->7365720a 1->7368732e 96106ace 1->7368732e 400->0 0->68732e00 
.... 2b02b->1 1bc01->7365720a 0->68732e00 0->68732e00 0->68732e00 28924->a138 2afff->127e4 28868->0 0->68732e00 
R0 (bin): 00000000000000000000010000000000
\end{lstlisting}
\caption{Behaviour of the champion of the \emph{xysxim} population, for a member of the red class. Input registers are \texttt{r2} and \texttt{r3}.}
\label{tab:xysxim-champ-red}
\end{table}

</div>

<div>
\begin{table}
\begin{lstlisting}
IN:  ffffff98 d
0000b4b4       | pop {r4, r5, r6, r7, r8, pc}
0000d9a8       | cmp r0, #0
0000d9ac       | moveq r0, r3
0000d9b0       | pop {r3, pc}
0001010c       | rsb r5, r5, r0
00010110       | cmp r5, #0x40
00010114       | movgt r0, #0
00010118       | movle r0, #1
0001011c       | pop {r4, r5, r6, pc}
0000cdd0       | subs r4, r0, #0
0000cdd4       | popeq {r4, r5, r6, pc}
0000d9ac       | moveq r0, r3
0000d9b0       | pop {r3, pc}
00016168       | add r0, r4, r0
0001616c       | pop {r3, r4, r5, pc}
0000ad94       | mov r0, r3
0000ad98       | pop {r4, pc}
0001228c       | add sp, sp, #0x364
00012290       | add sp, sp, #0x400
00012294       | pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}
OUT: ea->0 0->68732e00 ffffff98 ea->0 0->68732e00 0->68732e00 0->68732e00 
.... 0->68732e00 0->68732e00 0->68732e00 0->68732e00 0->68732e00 0->68732e00 2b7eb->0 0->68732e00 0->68732e00 
R0 (bin): 00000000000000000000000011101010
\end{lstlisting}
\caption{Behaviour of the champion of the \emph{xysxim} population, for a member of the blue class. Input registers are \texttt{r2} and \texttt{r3}.}
\label{tab:xysxim-champ-blue}
\end{table}

</div>

<p>
This still leaves the matter of input registers, however. One mitigation of the uneven use of
input registers that has already been implemented in roper is the possible use of the
stack to pass input parameters for each problem. This is done by associating with each
clump an <code>input_slots</code> field, which tells the execution procedure to replace the values at
certain, specified stack indexes in the rop payload with the available input values, which
offers much more flexibility, and adaptability, to the way the population handles input. 
</p>
</section>
<section id="slide-orgf46910c">
<h3 id="orgf46910c"><span class="section-number-3">7.2</span> Homologous crossover</h3>
<div class="outline-text-3" id="text-7-2">
</div>
</section>
<section id="slide-org6f9006d">
<h4 id="org6f9006d"><span class="section-number-4">7.2.1</span> The trouble with crossover</h4>
<p>
The trouble with crossover as it is currently implemented in roper, and with
the way it is canonically specified in most standard forms of gp,
is that it is, as Nordin and others put it <a href="~/org/bibliography.bib::nordin99">~/org/bibliography.bib::nordin99</a>, &ldquo;too <i>brutal</i>&rdquo;, and
insensitive to genomic context. The genome can be sliced more or less at random &#x2013;
in roper, tempered only slightly by the gentle weighting of splice-point probabilities
through the <i>fragility</i> mechanism discussed in <a href="#/slide-orgce7df1f">4.3.2.1</a> &#x2013; combining and substituting
genes without any regard to their form or function.
</p>


<div id="org021862b" class="figure">
<p><img src="../images/carboat-montage.png" alt="carboat-montage.png" />
</p>
<p><span class="figure-number">Figure 8: </span>Unconstrained crossover in action</p>
</div>

</section>
<section id="slide-org11595cf">
<h4 id="org11595cf"><span class="section-number-4">7.2.2</span> One way of implementing (quasi-)homologous crossover in ROPER</h4>
<p>
In natural organisms, crossover is a highly constrained and sophisticated mechanism. 
Under ordinary circumstances, only those genes sharing the same loci in their respective
chromosomes are candidates for sexual recombination. This particular notion of &ldquo;loci&rdquo;, 
however, has no genuine parallel in a canonical gp system. It would be a mistake to
translate it, simply, as &ldquo;index&rdquo;, since the ordering of a genome, at least at the beginning
of a run, has little structural significance with respect to function. A semantically richer
notion of structural position is desirable, here. Perhaps something like the <i>return address</i>
of the gadget correlated with a clump can provide an indirect proxy for loci. This should at
least correlate, noisily, with phenotypic behaviour patterns, and can be
assessed in unit time (since it is already stored in the clump&rsquo;s metadata)
adding no further overhead to our crossover algorithm. 
</p>




<p>
Semantically meaningful organic structure tends to be extraordinarily scarce at the
beginning of a run, and there&rsquo;s no reason why we should trust a poorly
performing genome on having gotten anything &ldquo;right&rdquo; in the order of its genes.
We don&rsquo;t want to <i>prematurely</i> constrain the possibilities of crossover, by enforcing
quasi-homological gene alignment on chains that may have very little interesting
organization in the first place. A sensible course of action would be to apply quasi-homological
constraints <i>probabilistically</i>, where the probability of application is proportionate to
at least one parent&rsquo;s fitness. Algorithm \ref{alg:crossover-homo} shows one way
this could be done. 
</p>

<div>
\begin{algorithm}
\caption{Quasi-homologous Crossver, using Return Address Alignment}
\label{alg:crossover-homo}
\begin{algorithmic}[1]

\REQUIRE $(\vec{\mu}, \vec{\varphi})$: ([\![ \textbf{clump} ]\!], [\![\textbf{clump} ]\!]), the parental genotypes 
\REQUIRE \emph{fragility}: [\![\textbf{clump} ]\!] $\times$ [\![ \textbf{clump} ]\!] $\times$ lineage $\to \mathbb{F}$ 
\REQUIRE $(\mathfrak{R}, s)$: a PRNG and seed 
\REQUIRE $n$: $\mathbb{N}$, brood size


\STATE {$\mathfrak{R} \gets \textit{seed}(\mathfrak{R}, s)$} 

\STATE
{$t \gets \sum_{\mu \in \vec{\mu}} 1.0 - \text{fragilty}(\mu)$}

\STATE {$p, \mathfrak{R} \gets \text{random-float}(\mathfrak{R}, t)$} \COMMENT
{$p$ is more likely to fall on a highly fragile link} 
\STATE {$x \gets 0$}

\STATE {$\mu_i \gets 0$} 
\WHILE {$x < p$} 
  \STATE {$x \gets x + \text{fragility}(\mu_i)$} 
  \STATE {$\mu_i \gets \mu_i + 1$} 
\ENDWHILE 

\COMMENT {We now have the "mother's" splice point, $\mu_i$. With a probability proportionate to her fitness, look for a homolog in the "father".}
\STATE {$x, \mathfrak{R} \gets \text{random-float}(\mathfrak{R},1.0)$}
\IF {$x > \mu_{\text{fitness}}$ \AND $(n,\mu_{i_{\text{ret}}}) \in \{(c_{\text{index}}, c_\text{ret}) | c \in \phi\}$}

   \STATE {$\phi_i \gets n$}
\ELSE 
   \STATE {$\phi_i \gets $ a random index, using the algorithm above}
\ENDIF

\STATE {$\mu^a, \mu^b \gets $ split $\mu$ at $\mu_i$}
\STATE {$\phi^a, \phi^b \gets $ split $\phi$ at $\phi_i$}
\STATE {$\chi^a \gets \mu^a \cup \varphi^a$} \COMMENT {with metadata reinitialized and updated}
\STATE {\textbf{For $\chi^b$, repeat with sexes reversed}}
\RETURN {$\chi^a, \chi^b$} \COMMENT {the offspring}
\end{algorithmic} 
\end{algorithm}

</div>

</section>
<section id="slide-org20eb220">
<h4 id="org20eb220"><span class="section-number-4">7.2.3</span> Experimental results of implementing quasi-homologous crossover in ROPER</h4>
<p>
Early experimental trials using this form of quasi-homologous crossover appear
to show a greater variance in the difference between the fitness of the spawn
of a crossover event, and the fitness of its parents, and a much greater
frequency at which crossover-span exhibit a fitness <i>superior</i> to the average
of their parents&rsquo;. 
</p>

</section>
<section id="slide-org3161c83">
<h4 id="org3161c83"><span class="section-number-4">7.2.4</span> Alternative approaches to the problem</h4>
<p>
A more nuanced approach may be possible, using runtime information
gleaned from the execution of the parents &#x2013; we could attempt to align 
clumps on the basis of a fuzzy match of their register states at the moment of
execution of their return instructions, perhaps. This would capture the intuition
of letting the paternal segment of the offspring <i>pick up where the maternal segment
left off</i>, semantically speaking.
</p>

<ul>
<li>TODO insert graphs</li>

</ul>
</section>
</section>
</div>
</div>
<script src="./reveal.js/lib/js/head.min.js"></script>
<script src="./reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: false,
center: true,
slideNumber: 'c',
rollingLinks: false,
keyboard: true,
overview: true,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: './reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: './reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: './reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: './reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
