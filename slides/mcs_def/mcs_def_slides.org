#+TITLE: Urschleim in Silicon: The Slideshow
#+OPTIONS: toc:1 num:nil

* Introductory Remarks
:PROPERTIES:
:reveal_background: ../images/roper.png
:reveal_background_trans: fade
:END:
* The Concept of Return-Oriented Programming
** The Fundamental Problem of Cybersecurity
At bottom, there is no essential distinction between data and code.

"Data" is just information your system trusts. 
** Consider the Stack
#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
[[../images/stack_frame.png]]
#+REVEAL_HTML: </div> <div class="column" style="float:left; width: 50%">

#+ATTR_REVEAL: :frag (appear appear appear appear appear) 
- the hacker feeds some input data to the process
- which is written to a buffer in stack memory
- but which overruns the buffer
- corrupting the frame's return address
#+REVEAL_HTML: </div>

** Consider the Stack, Smashed

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
[[../images/stack_frame_attack.png]]
#+REVEAL_HTML: </div>

#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
#+ATTR_REVEAL: :frag (none appear appear appear)
- so that it points into the buffer
- a buffer that turns out to contain machine code
- to which the program counter "returns"
- executing it just as it would its own instructions!
#+REVEAL_HTML: </div>

** DEP / $W \oplus X$
#+REVEAL_HTML: <div class="column" style="float:left; width: 50%">
[[../images/stack_frame_attack_w^x.png]]
#+REVEAL_HTML: </div><div class="column" style="float:left; width: 50%">
#+ATTR_REVEAL: :frag (appear appear)
- One way of mitigating this is to try to ensure that no page of memory is both writeable *and* executable.
- The idea being that /data/ should be writeable, but never executable, while /code/ should be executed, but not written at runtime.
#+REVEAL_HTML: </div>



** So, is code "wherever the program counter's pointing"?
** No. It's far worse than that. 
** Subverting $~W\oplus X$
#+ATTR_REVEAL: :frag (appear appear appear appear)
- $W\oplus X$ may prevent the /execution/ of input data, but it doesn't prevent attempts to /return/ to that data.
- Why should the hacker need to supply their own machine code?
- There's quite a bit just laying around, in executable memory.
- Why not just build a payload with whatever's handy?
** It's what MacGyver would do
:PROPERTIES:
:reveal_background: ../images/macgyver2-transparent.png
:reveal_background_trans: Zoom
:END:
#+ATTR_REVEAL: :frag (highlight-red)
But how?
** $W\oplus X~~$ is a Leaky Abstraction
#+ATTR_REVEAL: :frag (appear appear appear)
- It rests on all-too-narrow concepts of "instruction" and "execution".
- The payload's /instructions/ don't need to be bytes of machine code.
- They just need to influence control flow, in a controllable way.
** So is the /Structured Programming Machine Model/ 
#+ATTR_REVEAL: :frag (appear appear appear appear)
- The machine model structure programming is based already carves up an executable into chunks that *return* control after being dispatched.
- To the programmer, these are "functions", but this is too granular a viewpoint.
- /Any/ chunk of code ending with a *return* returns control to whomever controls the stack.
- And our data controls the stack!

** The ROVM supervenes on the SPMM
#+ATTR_REVEAL: :frag (appear appear appear appear appear)
- Chunks of code that allow the attacker to maintain control after dispatching are called "gadgets".
- They can be seen as the instruction set for another virtual machine.
- Call it a "Return-Oriented Virtual Machine". 
- It supervenes spontaneously on any process adhering to the SPMM.
- It's a "weird machine"
- and we can program it...

** ...and so can natural selection.

* Natural Selection Considered Harmful :noexport:

* Design and Implementation of ROPER

* Experimental Studies

** The Environment
[[../../thesis/images/tomato-RT-N18U-httpd_heatmap.png]]


** Tasks and Fitness Functions
- An arbitrary and inscrutable fitness function
- System call preparation
- Classification tasks:
  - An artificial, linearly-separable dataset
  - The Iris dataset
- A Snake game



*** Kafka function with Crash Penalty   

The address visitation heatmap shows no evident loss of diversity,
even after 212 seasons, suggesting a robustly ergodic system. 
[[../../thesis/images/plots/xeqcyv_kafka_heatmap_beginning_end.png]]


*** System Call Preparation
 
Champion of the /wiwzuh/ population:
#+BEGIN_SRC asm
  0000b4ac        pop {r4, r5, r6, r7, r8, pc}

  0000d1a0        cmp r0, #0
  0000d1a4        popeq {r3, r4, r5, pc}

  00016654        cmp r0, #0
  00016658        ldr r3, [pc, #4]
  0001665c        moveq r0, r3
  00016660        pop {r3, pc}

  0001706c        ldm sp, {r0, r1}
  00017070        add sp, sp, #0x10
  00017074        pop {r4, r5, r6, pc}

;; R0:  0001f62f   R2:  00000000
;; R1: &0001f62f   R7:  0000000b
  
;; to call execv("/tmp/flashXXXXXX", ["/tmp/flashXXXXXX"], NULL) 
  00018fc4        svcvc #0xffffff
#+END_SRC


*** Fitness landscape traversed by the /wiwzuh/ population
[[../../thesis/images/plots/wiwzuh_syscall_gaussian_3.png]]



*** A simple classification task

file:../images/plots/

*** The Snake Game
   
#+CAPTION: Champion of the /misjax/ population, and one of the better specimens encountered.
#+NAME: vid:snek-champ
file:../../videos/roper-snek-misjax-35000.mp4

* Recent and Future Work

** Recent

*** Bit-masks over Bid-bins

 The uneven distribution of register usage puts a skew on any
 classification task using the register bid-bin method. 
 [[../images/tomato.png]]

*** Bitmask technique for classification tasks



*** Specimens found when using the bitmask technique instead

#+BEGIN_EXAMPLE
 IN:  a3 fffffd6f
 0000b4b4       | pop {r4, r5, r6, r7, r8, pc}
 0000d9a8       | cmp r0, #0
 0000d9ac       | moveq r0, r3
 0000d9b0       | pop {r3, pc}
 0001010c       | rsb r5, r5, r0
 00010110       | cmp r5, #0x40
 00010114       | movgt r0, #0
 00010118       | movle r0, #1
 0001011c       | pop {r4, r5, r6, pc}
 0000cdd0       | subs r4, r0, #0
 0000cdd4       | popeq {r4, r5, r6, pc}
 0000cdd8 stray | ldr r1, [pc, #0x1c]
 0000cddc stray | mov r2, r4
 0000cde0 stray | mov r0, #0
 0000cde4 stray | bl #0x59e0
 000127c4 stray | push {r1, r2, r3}
 000127c8 stray | push {r0, r1, r2, r4, r5, r6, r7, r8, lr}
 000127cc stray | mov r6, r0
 000127d0 stray | mov r5, #0x400
 000127d4 stray | add r7, sp, #0x28
 000127d8 stray | ldr r8, [sp, #0x24]
 000127dc stray | mov r0, r5
 000127e0 stray | bl #4294933396
 0000a374 stray | add ip, pc, #0
 0000a378 stray | add ip, ip, #0x1e000
 0000a37c stray | ldr pc, [ip, #0x5a8]!
 0000a138 stray | str lr, [sp, #-4]!
 0000a13c stray | ldr lr, [pc, #4]
 0000a140 stray | add lr, pc, lr
 0000a144 stray | ldr pc, [lr, #8]!
 OUT: 400->0 1bc01->7365720a 1->7368732e 96106ace 1->7368732e 400->0 0->68732e00 
 .... 2b02b->1 1bc01->7365720a 0->68732e00 0->68732e00 0->68732e00 28924->a138 2afff->127e4 28868->0 0->68732e00 
 R0 (bin): 00000000000000000000010000000000
#+END_EXAMPLE

#+REVEAL: split

#+BEGIN_EXAMPLE
 IN:  ffffff98 d
 0000b4b4       | pop {r4, r5, r6, r7, r8, pc}
 0000d9a8       | cmp r0, #0
 0000d9ac       | moveq r0, r3
 0000d9b0       | pop {r3, pc}
 0001010c       | rsb r5, r5, r0
 00010110       | cmp r5, #0x40
 00010114       | movgt r0, #0
 00010118       | movle r0, #1
 0001011c       | pop {r4, r5, r6, pc}
 0000cdd0       | subs r4, r0, #0
 0000cdd4       | popeq {r4, r5, r6, pc}
 0000d9ac       | moveq r0, r3
 0000d9b0       | pop {r3, pc}
 00016168       | add r0, r4, r0
 0001616c       | pop {r3, r4, r5, pc}
 0000ad94       | mov r0, r3
 0000ad98       | pop {r4, pc}
 0001228c       | add sp, sp, #0x364
 00012290       | add sp, sp, #0x400
 00012294       | pop {r4, r5, r6, r7, r8, sb, sl, fp, pc}
 OUT: ea->0 0->68732e00 ffffff98 ea->0 0->68732e00 0->68732e00 0->68732e00 
 .... 0->68732e00 0->68732e00 0->68732e00 0->68732e00 0->68732e00 0->68732e00 2b7eb->0 0->68732e00 0->68732e00 
 R0 (bin): 00000000000000000000000011101010
#+END_EXAMPLE

*** TTL fields on Clumps

*** Quasi-Homologous Crossover

** 

